<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="robots" content="noindex,nofollow" />
        <style>
            /* Copyright (c) 2010, Yahoo! Inc. All rights reserved. Code licensed under the BSD License: http://developer.yahoo.com/yui/license.html */
            html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;}input,textarea,select{*font-size:100%;}legend{color:#000;}

            html { background: #eee; padding: 10px }
            img { border: 0; }
            #sf-resetcontent { width:970px; margin:0 auto; }
                        .sf-reset { font: 11px Verdana, Arial, sans-serif; color: #333 }
            .sf-reset .clear { clear:both; height:0; font-size:0; line-height:0; }
            .sf-reset .clear_fix:after { display:block; height:0; clear:both; visibility:hidden; }
            .sf-reset .clear_fix { display:inline-block; }
            .sf-reset * html .clear_fix { height:1%; }
            .sf-reset .clear_fix { display:block; }
            .sf-reset, .sf-reset .block { margin: auto }
            .sf-reset abbr { border-bottom: 1px dotted #000; cursor: help; }
            .sf-reset p { font-size:14px; line-height:20px; color:#868686; padding-bottom:20px }
            .sf-reset strong { font-weight:bold; }
            .sf-reset a { color:#6c6159; cursor: default; }
            .sf-reset a img { border:none; }
            .sf-reset a:hover { text-decoration:underline; }
            .sf-reset em { font-style:italic; }
            .sf-reset h1, .sf-reset h2 { font: 20px Georgia, "Times New Roman", Times, serif }
            .sf-reset .exception_counter { background-color: #fff; color: #333; padding: 6px; float: left; margin-right: 10px; float: left; display: block; }
            .sf-reset .exception_title { margin-left: 3em; margin-bottom: 0.7em; display: block; }
            .sf-reset .exception_message { margin-left: 3em; display: block; }
            .sf-reset .traces li { font-size:12px; padding: 2px 4px; list-style-type:decimal; margin-left:20px; }
            .sf-reset .block { background-color:#FFFFFF; padding:10px 28px; margin-bottom:20px;
                -webkit-border-bottom-right-radius: 16px;
                -webkit-border-bottom-left-radius: 16px;
                -moz-border-radius-bottomright: 16px;
                -moz-border-radius-bottomleft: 16px;
                border-bottom-right-radius: 16px;
                border-bottom-left-radius: 16px;
                border-bottom:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
            }
            .sf-reset .block_exception { background-color:#ddd; color: #333; padding:20px;
                -webkit-border-top-left-radius: 16px;
                -webkit-border-top-right-radius: 16px;
                -moz-border-radius-topleft: 16px;
                -moz-border-radius-topright: 16px;
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-top:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
                overflow: hidden;
                word-wrap: break-word;
            }
            .sf-reset a { background:none; color:#868686; text-decoration:none; }
            .sf-reset a:hover { background:none; color:#313131; text-decoration:underline; }
            .sf-reset ol { padding: 10px 0; }
            .sf-reset h1 { background-color:#FFFFFF; padding: 15px 28px; margin-bottom: 20px;
                -webkit-border-radius: 10px;
                -moz-border-radius: 10px;
                border-radius: 10px;
                border: 1px solid #ccc;
            }
        </style>
    </head>
    <body>
                    <div id="sf-resetcontent" class="sf-reset">
                <h1>Whoops, looks like something went wrong.</h1>
                                        <h2 class="block_exception clear_fix">
                            <span class="exception_counter">1/1</span>
                            <span class="exception_title"><abbr title="RuntimeException">RuntimeException</abbr> in <a title="/home/hab/public_html/test/vendor/symfony/symfony/src/Symfony/Component/ClassLoader/ClassCollectionLoader.php line 248" ondblclick="var f=this.innerHTML;this.innerHTML=this.title;this.title=f;">ClassCollectionLoader.php line 248</a>:</span>
                            <span class="exception_message">Failed to write cache file &quot;/home/hab/public_html/test/app/cache/dev/classes.php&quot;.</span>
                        </h2>
                        <div class="block">
                            <ol class="traces list_exception">
       <li> in <a title="/home/hab/public_html/test/vendor/symfony/symfony/src/Symfony/Component/ClassLoader/ClassCollectionLoader.php line 248" ondblclick="var f=this.innerHTML;this.innerHTML=this.title;this.title=f;">ClassCollectionLoader.php line 248</a></li>
       <li>at <abbr title="Symfony\Component\ClassLoader\ClassCollectionLoader">ClassCollectionLoader</abbr>::writeCacheFile('/home/hab/public_html/test/app/cache/dev/classes.php', '&lt;?php 
namespace Symfony\Component\EventDispatcher
{
interface EventSubscriberInterface
{
public static function getSubscribedEvents();
}
}
namespace Symfony\Component\HttpKernel\EventListener
{
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
abstract class SessionListener implements EventSubscriberInterface
{
public function onKernelRequest(GetResponseEvent $event)
{
if (!$event-&gt;isMasterRequest()) {
return;
}
$request = $event-&gt;getRequest();
$session = $this-&gt;getSession();
if (null === $session || $request-&gt;hasSession()) {
return;
}
$request-&gt;setSession($session);
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::REQUEST =&gt; array(&#039;onKernelRequest&#039;, 128),
);
}
abstract protected function getSession();
}
}
namespace Symfony\Bundle\FrameworkBundle\EventListener
{
use Symfony\Component\HttpKernel\EventListener\SessionListener as BaseSessionListener;
use Symfony\Component\DependencyInjection\ContainerInterface;
class SessionListener extends BaseSessionListener
{
private $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
protected function getSession()
{
if (!$this-&gt;container-&gt;has(&#039;session&#039;)) {
return;
}
return $this-&gt;container-&gt;get(&#039;session&#039;);
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage
{
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
interface SessionStorageInterface
{
public function start();
public function isStarted();
public function getId();
public function setId($id);
public function getName();
public function setName($name);
public function regenerate($destroy = false, $lifetime = null);
public function save();
public function clear();
public function getBag($name);
public function registerBag(SessionBagInterface $bag);
public function getMetadataBag();
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage
{
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeSessionHandler;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\NativeProxy;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\AbstractProxy;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\SessionHandlerProxy;
class NativeSessionStorage implements SessionStorageInterface
{
protected $bags;
protected $started = false;
protected $closed = false;
protected $saveHandler;
protected $metadataBag;
public function __construct(array $options = array(), $handler = null, MetadataBag $metaBag = null)
{
session_cache_limiter(&#039;&#039;); ini_set(&#039;session.use_cookies&#039;, 1);
session_register_shutdown();
$this-&gt;setMetadataBag($metaBag);
$this-&gt;setOptions($options);
$this-&gt;setSaveHandler($handler);
}
public function getSaveHandler()
{
return $this-&gt;saveHandler;
}
public function start()
{
if ($this-&gt;started) {
return true;
}
if (PHP_VERSION_ID &gt;= 50400 &amp;&amp; \PHP_SESSION_ACTIVE === session_status()) {
throw new \RuntimeException(&#039;Failed to start the session: already started by PHP.&#039;);
}
if (PHP_VERSION_ID &lt; 50400 &amp;&amp; !$this-&gt;closed &amp;&amp; isset($_SESSION) &amp;&amp; session_id()) {
throw new \RuntimeException(&#039;Failed to start the session: already started by PHP ($_SESSION is set).&#039;);
}
if (ini_get(&#039;session.use_cookies&#039;) &amp;&amp; headers_sent($file, $line)) {
throw new \RuntimeException(sprintf(&#039;Failed to start the session because headers have already been sent by &quot;%s&quot; at line %d.&#039;, $file, $line));
}
if (!session_start()) {
throw new \RuntimeException(&#039;Failed to start the session&#039;);
}
$this-&gt;loadSession();
if (!$this-&gt;saveHandler-&gt;isWrapper() &amp;&amp; !$this-&gt;saveHandler-&gt;isSessionHandlerInterface()) {
$this-&gt;saveHandler-&gt;setActive(true);
}
return true;
}
public function getId()
{
return $this-&gt;saveHandler-&gt;getId();
}
public function setId($id)
{
$this-&gt;saveHandler-&gt;setId($id);
}
public function getName()
{
return $this-&gt;saveHandler-&gt;getName();
}
public function setName($name)
{
$this-&gt;saveHandler-&gt;setName($name);
}
public function regenerate($destroy = false, $lifetime = null)
{
if (PHP_VERSION_ID &gt;= 50400 &amp;&amp; \PHP_SESSION_ACTIVE !== session_status()) {
return false;
}
if (PHP_VERSION_ID &lt; 50400 &amp;&amp;&#039;&#039;=== session_id()) {
return false;
}
if (null !== $lifetime) {
ini_set(&#039;session.cookie_lifetime&#039;, $lifetime);
}
if ($destroy) {
$this-&gt;metadataBag-&gt;stampNew();
}
$isRegenerated = session_regenerate_id($destroy);
$this-&gt;loadSession();
return $isRegenerated;
}
public function save()
{
session_write_close();
if (!$this-&gt;saveHandler-&gt;isWrapper() &amp;&amp; !$this-&gt;saveHandler-&gt;isSessionHandlerInterface()) {
$this-&gt;saveHandler-&gt;setActive(false);
}
$this-&gt;closed = true;
$this-&gt;started = false;
}
public function clear()
{
foreach ($this-&gt;bags as $bag) {
$bag-&gt;clear();
}
$_SESSION = array();
$this-&gt;loadSession();
}
public function registerBag(SessionBagInterface $bag)
{
$this-&gt;bags[$bag-&gt;getName()] = $bag;
}
public function getBag($name)
{
if (!isset($this-&gt;bags[$name])) {
throw new \InvalidArgumentException(sprintf(&#039;The SessionBagInterface %s is not registered.&#039;, $name));
}
if ($this-&gt;saveHandler-&gt;isActive() &amp;&amp; !$this-&gt;started) {
$this-&gt;loadSession();
} elseif (!$this-&gt;started) {
$this-&gt;start();
}
return $this-&gt;bags[$name];
}
public function setMetadataBag(MetadataBag $metaBag = null)
{
if (null === $metaBag) {
$metaBag = new MetadataBag();
}
$this-&gt;metadataBag = $metaBag;
}
public function getMetadataBag()
{
return $this-&gt;metadataBag;
}
public function isStarted()
{
return $this-&gt;started;
}
public function setOptions(array $options)
{
$validOptions = array_flip(array(&#039;cache_limiter&#039;,&#039;cookie_domain&#039;,&#039;cookie_httponly&#039;,&#039;cookie_lifetime&#039;,&#039;cookie_path&#039;,&#039;cookie_secure&#039;,&#039;entropy_file&#039;,&#039;entropy_length&#039;,&#039;gc_divisor&#039;,&#039;gc_maxlifetime&#039;,&#039;gc_probability&#039;,&#039;hash_bits_per_character&#039;,&#039;hash_function&#039;,&#039;name&#039;,&#039;referer_check&#039;,&#039;serialize_handler&#039;,&#039;use_cookies&#039;,&#039;use_only_cookies&#039;,&#039;use_trans_sid&#039;,&#039;upload_progress.enabled&#039;,&#039;upload_progress.cleanup&#039;,&#039;upload_progress.prefix&#039;,&#039;upload_progress.name&#039;,&#039;upload_progress.freq&#039;,&#039;upload_progress.min-freq&#039;,&#039;url_rewriter.tags&#039;,
));
foreach ($options as $key =&gt; $value) {
if (isset($validOptions[$key])) {
ini_set(&#039;session.&#039;.$key, $value);
}
}
}
public function setSaveHandler($saveHandler = null)
{
if (!$saveHandler instanceof AbstractProxy &amp;&amp;
!$saveHandler instanceof NativeSessionHandler &amp;&amp;
!$saveHandler instanceof \SessionHandlerInterface &amp;&amp;
null !== $saveHandler) {
throw new \InvalidArgumentException(&#039;Must be instance of AbstractProxy or NativeSessionHandler; implement \SessionHandlerInterface; or be null.&#039;);
}
if (!$saveHandler instanceof AbstractProxy &amp;&amp; $saveHandler instanceof \SessionHandlerInterface) {
$saveHandler = new SessionHandlerProxy($saveHandler);
} elseif (!$saveHandler instanceof AbstractProxy) {
$saveHandler = PHP_VERSION_ID &gt;= 50400 ?
new SessionHandlerProxy(new \SessionHandler()) : new NativeProxy();
}
$this-&gt;saveHandler = $saveHandler;
if ($this-&gt;saveHandler instanceof \SessionHandlerInterface) {
if (PHP_VERSION_ID &gt;= 50400) {
session_set_save_handler($this-&gt;saveHandler, false);
} else {
session_set_save_handler(
array($this-&gt;saveHandler,&#039;open&#039;),
array($this-&gt;saveHandler,&#039;close&#039;),
array($this-&gt;saveHandler,&#039;read&#039;),
array($this-&gt;saveHandler,&#039;write&#039;),
array($this-&gt;saveHandler,&#039;destroy&#039;),
array($this-&gt;saveHandler,&#039;gc&#039;)
);
}
}
}
protected function loadSession(array &amp;$session = null)
{
if (null === $session) {
$session = &amp;$_SESSION;
}
$bags = array_merge($this-&gt;bags, array($this-&gt;metadataBag));
foreach ($bags as $bag) {
$key = $bag-&gt;getStorageKey();
$session[$key] = isset($session[$key]) ? $session[$key] : array();
$bag-&gt;initialize($session[$key]);
}
$this-&gt;started = true;
$this-&gt;closed = false;
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage
{
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\AbstractProxy;
use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeSessionHandler;
class PhpBridgeSessionStorage extends NativeSessionStorage
{
public function __construct($handler = null, MetadataBag $metaBag = null)
{
$this-&gt;setMetadataBag($metaBag);
$this-&gt;setSaveHandler($handler);
}
public function start()
{
if ($this-&gt;started) {
return true;
}
$this-&gt;loadSession();
if (!$this-&gt;saveHandler-&gt;isWrapper() &amp;&amp; !$this-&gt;saveHandler-&gt;isSessionHandlerInterface()) {
$this-&gt;saveHandler-&gt;setActive(true);
}
return true;
}
public function clear()
{
foreach ($this-&gt;bags as $bag) {
$bag-&gt;clear();
}
$this-&gt;loadSession();
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Handler
{
if (PHP_VERSION_ID &gt;= 50400) {
class NativeSessionHandler extends \SessionHandler
{
}
} else {
class NativeSessionHandler
{
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Handler
{
class NativeFileSessionHandler extends NativeSessionHandler
{
public function __construct($savePath = null)
{
if (null === $savePath) {
$savePath = ini_get(&#039;session.save_path&#039;);
}
$baseDir = $savePath;
if ($count = substr_count($savePath,&#039;;&#039;)) {
if ($count &gt; 2) {
throw new \InvalidArgumentException(sprintf(&#039;Invalid argument $savePath \&#039;%s\&#039;&#039;, $savePath));
}
$baseDir = ltrim(strrchr($savePath,&#039;;&#039;),&#039;;&#039;);
}
if ($baseDir &amp;&amp; !is_dir($baseDir) &amp;&amp; !@mkdir($baseDir, 0777, true) &amp;&amp; !is_dir($baseDir)) {
throw new \RuntimeException(sprintf(&#039;Session Storage was not able to create directory &quot;%s&quot;&#039;, $baseDir));
}
ini_set(&#039;session.save_path&#039;, $savePath);
ini_set(&#039;session.save_handler&#039;,&#039;files&#039;);
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Proxy
{
abstract class AbstractProxy
{
protected $wrapper = false;
protected $active = false;
protected $saveHandlerName;
public function getSaveHandlerName()
{
return $this-&gt;saveHandlerName;
}
public function isSessionHandlerInterface()
{
return $this instanceof \SessionHandlerInterface;
}
public function isWrapper()
{
return $this-&gt;wrapper;
}
public function isActive()
{
if (PHP_VERSION_ID &gt;= 50400) {
return $this-&gt;active = \PHP_SESSION_ACTIVE === session_status();
}
return $this-&gt;active;
}
public function setActive($flag)
{
if (PHP_VERSION_ID &gt;= 50400) {
throw new \LogicException(&#039;This method is disabled in PHP 5.4.0+&#039;);
}
$this-&gt;active = (bool) $flag;
}
public function getId()
{
return session_id();
}
public function setId($id)
{
if ($this-&gt;isActive()) {
throw new \LogicException(&#039;Cannot change the ID of an active session&#039;);
}
session_id($id);
}
public function getName()
{
return session_name();
}
public function setName($name)
{
if ($this-&gt;isActive()) {
throw new \LogicException(&#039;Cannot change the name of an active session&#039;);
}
session_name($name);
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Proxy
{
class SessionHandlerProxy extends AbstractProxy implements \SessionHandlerInterface
{
protected $handler;
public function __construct(\SessionHandlerInterface $handler)
{
$this-&gt;handler = $handler;
$this-&gt;wrapper = ($handler instanceof \SessionHandler);
$this-&gt;saveHandlerName = $this-&gt;wrapper ? ini_get(&#039;session.save_handler&#039;) :&#039;user&#039;;
}
public function open($savePath, $sessionName)
{
$return = (bool) $this-&gt;handler-&gt;open($savePath, $sessionName);
if (true === $return) {
$this-&gt;active = true;
}
return $return;
}
public function close()
{
$this-&gt;active = false;
return (bool) $this-&gt;handler-&gt;close();
}
public function read($sessionId)
{
return (string) $this-&gt;handler-&gt;read($sessionId);
}
public function write($sessionId, $data)
{
return (bool) $this-&gt;handler-&gt;write($sessionId, $data);
}
public function destroy($sessionId)
{
return (bool) $this-&gt;handler-&gt;destroy($sessionId);
}
public function gc($maxlifetime)
{
return (bool) $this-&gt;handler-&gt;gc($maxlifetime);
}
}
}
namespace Symfony\Component\HttpFoundation\Session
{
use Symfony\Component\HttpFoundation\Session\Storage\MetadataBag;
interface SessionInterface
{
public function start();
public function getId();
public function setId($id);
public function getName();
public function setName($name);
public function invalidate($lifetime = null);
public function migrate($destroy = false, $lifetime = null);
public function save();
public function has($name);
public function get($name, $default = null);
public function set($name, $value);
public function all();
public function replace(array $attributes);
public function remove($name);
public function clear();
public function isStarted();
public function registerBag(SessionBagInterface $bag);
public function getBag($name);
public function getMetadataBag();
}
}
namespace Symfony\Component\HttpFoundation\Session
{
use Symfony\Component\HttpFoundation\Session\Storage\SessionStorageInterface;
use Symfony\Component\HttpFoundation\Session\Attribute\AttributeBag;
use Symfony\Component\HttpFoundation\Session\Attribute\AttributeBagInterface;
use Symfony\Component\HttpFoundation\Session\Flash\FlashBag;
use Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage;
class Session implements SessionInterface, \IteratorAggregate, \Countable
{
protected $storage;
private $flashName;
private $attributeName;
public function __construct(SessionStorageInterface $storage = null, AttributeBagInterface $attributes = null, FlashBagInterface $flashes = null)
{
$this-&gt;storage = $storage ?: new NativeSessionStorage();
$attributes = $attributes ?: new AttributeBag();
$this-&gt;attributeName = $attributes-&gt;getName();
$this-&gt;registerBag($attributes);
$flashes = $flashes ?: new FlashBag();
$this-&gt;flashName = $flashes-&gt;getName();
$this-&gt;registerBag($flashes);
}
public function start()
{
return $this-&gt;storage-&gt;start();
}
public function has($name)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;has($name);
}
public function get($name, $default = null)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;get($name, $default);
}
public function set($name, $value)
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;set($name, $value);
}
public function all()
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all();
}
public function replace(array $attributes)
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;replace($attributes);
}
public function remove($name)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;remove($name);
}
public function clear()
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;clear();
}
public function isStarted()
{
return $this-&gt;storage-&gt;isStarted();
}
public function getIterator()
{
return new \ArrayIterator($this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all());
}
public function count()
{
return count($this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all());
}
public function invalidate($lifetime = null)
{
$this-&gt;storage-&gt;clear();
return $this-&gt;migrate(true, $lifetime);
}
public function migrate($destroy = false, $lifetime = null)
{
return $this-&gt;storage-&gt;regenerate($destroy, $lifetime);
}
public function save()
{
$this-&gt;storage-&gt;save();
}
public function getId()
{
return $this-&gt;storage-&gt;getId();
}
public function setId($id)
{
$this-&gt;storage-&gt;setId($id);
}
public function getName()
{
return $this-&gt;storage-&gt;getName();
}
public function setName($name)
{
$this-&gt;storage-&gt;setName($name);
}
public function getMetadataBag()
{
return $this-&gt;storage-&gt;getMetadataBag();
}
public function registerBag(SessionBagInterface $bag)
{
$this-&gt;storage-&gt;registerBag($bag);
}
public function getBag($name)
{
return $this-&gt;storage-&gt;getBag($name);
}
public function getFlashBag()
{
return $this-&gt;getBag($this-&gt;flashName);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\Security\Core\SecurityContext;
class GlobalVariables
{
protected $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function getSecurity()
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method is deprecated since version 2.6 and will be removed in 3.0.&#039;, E_USER_DEPRECATED);
if ($this-&gt;container-&gt;has(&#039;security.context&#039;)) {
return $this-&gt;container-&gt;get(&#039;security.context&#039;);
}
}
public function getUser()
{
if (!$this-&gt;container-&gt;has(&#039;security.token_storage&#039;)) {
return;
}
$tokenStorage = $this-&gt;container-&gt;get(&#039;security.token_storage&#039;);
if (!$token = $tokenStorage-&gt;getToken()) {
return;
}
$user = $token-&gt;getUser();
if (!is_object($user)) {
return;
}
return $user;
}
public function getRequest()
{
if ($this-&gt;container-&gt;has(&#039;request_stack&#039;)) {
return $this-&gt;container-&gt;get(&#039;request_stack&#039;)-&gt;getCurrentRequest();
}
}
public function getSession()
{
if ($request = $this-&gt;getRequest()) {
return $request-&gt;getSession();
}
}
public function getEnvironment()
{
return $this-&gt;container-&gt;getParameter(&#039;kernel.environment&#039;);
}
public function getDebug()
{
return (bool) $this-&gt;container-&gt;getParameter(&#039;kernel.debug&#039;);
}
}
}
namespace Symfony\Component\Templating
{
interface TemplateReferenceInterface
{
public function all();
public function set($name, $value);
public function get($name);
public function getPath();
public function getLogicalName();
public function __toString();
}
}
namespace Symfony\Component\Templating
{
class TemplateReference implements TemplateReferenceInterface
{
protected $parameters;
public function __construct($name = null, $engine = null)
{
$this-&gt;parameters = array(&#039;name&#039;=&gt; $name,&#039;engine&#039;=&gt; $engine,
);
}
public function __toString()
{
return $this-&gt;getLogicalName();
}
public function set($name, $value)
{
if (array_key_exists($name, $this-&gt;parameters)) {
$this-&gt;parameters[$name] = $value;
} else {
throw new \InvalidArgumentException(sprintf(&#039;The template does not support the &quot;%s&quot; parameter.&#039;, $name));
}
return $this;
}
public function get($name)
{
if (array_key_exists($name, $this-&gt;parameters)) {
return $this-&gt;parameters[$name];
}
throw new \InvalidArgumentException(sprintf(&#039;The template does not support the &quot;%s&quot; parameter.&#039;, $name));
}
public function all()
{
return $this-&gt;parameters;
}
public function getPath()
{
return $this-&gt;parameters[&#039;name&#039;];
}
public function getLogicalName()
{
return $this-&gt;parameters[&#039;name&#039;];
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\Templating\TemplateReference as BaseTemplateReference;
class TemplateReference extends BaseTemplateReference
{
public function __construct($bundle = null, $controller = null, $name = null, $format = null, $engine = null)
{
$this-&gt;parameters = array(&#039;bundle&#039;=&gt; $bundle,&#039;controller&#039;=&gt; $controller,&#039;name&#039;=&gt; $name,&#039;format&#039;=&gt; $format,&#039;engine&#039;=&gt; $engine,
);
}
public function getPath()
{
$controller = str_replace(&#039;\\&#039;,&#039;/&#039;, $this-&gt;get(&#039;controller&#039;));
$path = (empty($controller) ?&#039;&#039;: $controller.&#039;/&#039;).$this-&gt;get(&#039;name&#039;).&#039;.&#039;.$this-&gt;get(&#039;format&#039;).&#039;.&#039;.$this-&gt;get(&#039;engine&#039;);
return empty($this-&gt;parameters[&#039;bundle&#039;]) ?&#039;views/&#039;.$path :&#039;@&#039;.$this-&gt;get(&#039;bundle&#039;).&#039;/Resources/views/&#039;.$path;
}
public function getLogicalName()
{
return sprintf(&#039;%s:%s:%s.%s.%s&#039;, $this-&gt;parameters[&#039;bundle&#039;], $this-&gt;parameters[&#039;controller&#039;], $this-&gt;parameters[&#039;name&#039;], $this-&gt;parameters[&#039;format&#039;], $this-&gt;parameters[&#039;engine&#039;]);
}
}
}
namespace Symfony\Component\Templating
{
interface TemplateNameParserInterface
{
public function parse($name);
}
}
namespace Symfony\Component\Templating
{
class TemplateNameParser implements TemplateNameParserInterface
{
public function parse($name)
{
if ($name instanceof TemplateReferenceInterface) {
return $name;
}
$engine = null;
if (false !== $pos = strrpos($name,&#039;.&#039;)) {
$engine = substr($name, $pos + 1);
}
return new TemplateReference($name, $engine);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\Templating\TemplateReferenceInterface;
use Symfony\Component\HttpKernel\KernelInterface;
use Symfony\Component\Templating\TemplateNameParser as BaseTemplateNameParser;
class TemplateNameParser extends BaseTemplateNameParser
{
protected $kernel;
protected $cache = array();
public function __construct(KernelInterface $kernel)
{
$this-&gt;kernel = $kernel;
}
public function parse($name)
{
if ($name instanceof TemplateReferenceInterface) {
return $name;
} elseif (isset($this-&gt;cache[$name])) {
return $this-&gt;cache[$name];
}
$name = str_replace(&#039;:/&#039;,&#039;:&#039;, preg_replace(&#039;#/{2,}#&#039;,&#039;/&#039;, str_replace(&#039;\\&#039;,&#039;/&#039;, $name)));
if (false !== strpos($name,&#039;..&#039;)) {
throw new \RuntimeException(sprintf(&#039;Template name &quot;%s&quot; contains invalid characters.&#039;, $name));
}
if (!preg_match(&#039;/^(?:([^:]*):)?(?:([^:]*):)?(.+)\.([^\.]+)\.([^\.]+)$/&#039;, $name, $matches)) {
return parent::parse($name);
}
$template = new TemplateReference($matches[1], $matches[2], $matches[3], $matches[4], $matches[5]);
if ($template-&gt;get(&#039;bundle&#039;)) {
try {
$this-&gt;kernel-&gt;getBundle($template-&gt;get(&#039;bundle&#039;));
} catch (\Exception $e) {
throw new \InvalidArgumentException(sprintf(&#039;Template name &quot;%s&quot; is not valid.&#039;, $name), 0, $e);
}
}
return $this-&gt;cache[$name] = $template;
}
}
}
namespace Symfony\Component\Config
{
interface FileLocatorInterface
{
public function locate($name, $currentPath = null, $first = true);
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating\Loader
{
use Symfony\Component\Config\FileLocatorInterface;
use Symfony\Component\Templating\TemplateReferenceInterface;
class TemplateLocator implements FileLocatorInterface
{
protected $locator;
protected $cache;
public function __construct(FileLocatorInterface $locator, $cacheDir = null)
{
if (null !== $cacheDir &amp;&amp; is_file($cache = $cacheDir.&#039;/templates.php&#039;)) {
$this-&gt;cache = require $cache;
}
$this-&gt;locator = $locator;
}
protected function getCacheKey($template)
{
return $template-&gt;getLogicalName();
}
public function locate($template, $currentPath = null, $first = true)
{
if (!$template instanceof TemplateReferenceInterface) {
throw new \InvalidArgumentException(&#039;The template must be an instance of TemplateReferenceInterface.&#039;);
}
$key = $this-&gt;getCacheKey($template);
if (isset($this-&gt;cache[$key])) {
return $this-&gt;cache[$key];
}
try {
return $this-&gt;cache[$key] = $this-&gt;locator-&gt;locate($template-&gt;getPath(), $currentPath);
} catch (\InvalidArgumentException $e) {
throw new \InvalidArgumentException(sprintf(&#039;Unable to find template &quot;%s&quot; : &quot;%s&quot;.&#039;, $template, $e-&gt;getMessage()), 0, $e);
}
}
}
}
namespace Symfony\Component\Routing
{
interface RequestContextAwareInterface
{
public function setContext(RequestContext $context);
public function getContext();
}
}
namespace Symfony\Component\Routing\Generator
{
use Symfony\Component\Routing\Exception\InvalidParameterException;
use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
use Symfony\Component\Routing\Exception\RouteNotFoundException;
use Symfony\Component\Routing\RequestContextAwareInterface;
interface UrlGeneratorInterface extends RequestContextAwareInterface
{
const ABSOLUTE_URL = 0;
const ABSOLUTE_PATH = 1;
const RELATIVE_PATH = 2;
const NETWORK_PATH = 3;
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH);
}
}
namespace Symfony\Component\Routing\Generator
{
interface ConfigurableRequirementsInterface
{
public function setStrictRequirements($enabled);
public function isStrictRequirements();
}
}
namespace Symfony\Component\Routing\Generator
{
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\Exception\InvalidParameterException;
use Symfony\Component\Routing\Exception\RouteNotFoundException;
use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
use Psr\Log\LoggerInterface;
class UrlGenerator implements UrlGeneratorInterface, ConfigurableRequirementsInterface
{
protected $routes;
protected $context;
protected $strictRequirements = true;
protected $logger;
protected $decodedChars = array(&#039;%2F&#039;=&gt;&#039;/&#039;,&#039;%40&#039;=&gt;&#039;@&#039;,&#039;%3A&#039;=&gt;&#039;:&#039;,&#039;%3B&#039;=&gt;&#039;;&#039;,&#039;%2C&#039;=&gt;&#039;,&#039;,&#039;%3D&#039;=&gt;&#039;=&#039;,&#039;%2B&#039;=&gt;&#039;+&#039;,&#039;%21&#039;=&gt;&#039;!&#039;,&#039;%2A&#039;=&gt;&#039;*&#039;,&#039;%7C&#039;=&gt;&#039;|&#039;,
);
public function __construct(RouteCollection $routes, RequestContext $context, LoggerInterface $logger = null)
{
$this-&gt;routes = $routes;
$this-&gt;context = $context;
$this-&gt;logger = $logger;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
}
public function getContext()
{
return $this-&gt;context;
}
public function setStrictRequirements($enabled)
{
$this-&gt;strictRequirements = null === $enabled ? null : (bool) $enabled;
}
public function isStrictRequirements()
{
return $this-&gt;strictRequirements;
}
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH)
{
if (null === $route = $this-&gt;routes-&gt;get($name)) {
throw new RouteNotFoundException(sprintf(&#039;Unable to generate a URL for the named route &quot;%s&quot; as such route does not exist.&#039;, $name));
}
$compiledRoute = $route-&gt;compile();
return $this-&gt;doGenerate($compiledRoute-&gt;getVariables(), $route-&gt;getDefaults(), $route-&gt;getRequirements(), $compiledRoute-&gt;getTokens(), $parameters, $name, $referenceType, $compiledRoute-&gt;getHostTokens(), $route-&gt;getSchemes());
}
protected function doGenerate($variables, $defaults, $requirements, $tokens, $parameters, $name, $referenceType, $hostTokens, array $requiredSchemes = array())
{
if (is_bool($referenceType) || is_string($referenceType)) {
@trigger_error(&#039;The hardcoded value you are using for the $referenceType argument of the &#039;.__CLASS__.&#039;::generate method is deprecated since version 2.8 and will not be supported anymore in 3.0. Use the constants defined in the UrlGeneratorInterface instead.&#039;, E_USER_DEPRECATED);
if (true === $referenceType) {
$referenceType = self::ABSOLUTE_URL;
} elseif (false === $referenceType) {
$referenceType = self::ABSOLUTE_PATH;
} elseif (&#039;relative&#039;=== $referenceType) {
$referenceType = self::RELATIVE_PATH;
} elseif (&#039;network&#039;=== $referenceType) {
$referenceType = self::NETWORK_PATH;
}
}
$variables = array_flip($variables);
$mergedParams = array_replace($defaults, $this-&gt;context-&gt;getParameters(), $parameters);
if ($diff = array_diff_key($variables, $mergedParams)) {
throw new MissingMandatoryParametersException(sprintf(&#039;Some mandatory parameters are missing (&quot;%s&quot;) to generate a URL for route &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, array_keys($diff)), $name));
}
$url =&#039;&#039;;
$optional = true;
foreach ($tokens as $token) {
if (&#039;variable&#039;=== $token[0]) {
if (!$optional || !array_key_exists($token[3], $defaults) || null !== $mergedParams[$token[3]] &amp;&amp; (string) $mergedParams[$token[3]] !== (string) $defaults[$token[3]]) {
if (null !== $this-&gt;strictRequirements &amp;&amp; !preg_match(&#039;#^&#039;.$token[2].&#039;$#&#039;, $mergedParams[$token[3]])) {
$message = sprintf(&#039;Parameter &quot;%s&quot; for route &quot;%s&quot; must match &quot;%s&quot; (&quot;%s&quot; given) to generate a corresponding URL.&#039;, $token[3], $name, $token[2], $mergedParams[$token[3]]);
if ($this-&gt;strictRequirements) {
throw new InvalidParameterException($message);
}
if ($this-&gt;logger) {
$this-&gt;logger-&gt;error($message);
}
return;
}
$url = $token[1].$mergedParams[$token[3]].$url;
$optional = false;
}
} else {
$url = $token[1].$url;
$optional = false;
}
}
if (&#039;&#039;=== $url) {
$url =&#039;/&#039;;
}
$url = strtr(rawurlencode($url), $this-&gt;decodedChars);
$url = strtr($url, array(&#039;/../&#039;=&gt;&#039;/%2E%2E/&#039;,&#039;/./&#039;=&gt;&#039;/%2E/&#039;));
if (&#039;/..&#039;=== substr($url, -3)) {
$url = substr($url, 0, -2).&#039;%2E%2E&#039;;
} elseif (&#039;/.&#039;=== substr($url, -2)) {
$url = substr($url, 0, -1).&#039;%2E&#039;;
}
$schemeAuthority =&#039;&#039;;
if ($host = $this-&gt;context-&gt;getHost()) {
$scheme = $this-&gt;context-&gt;getScheme();
if ($requiredSchemes) {
$schemeMatched = false;
foreach ($requiredSchemes as $requiredScheme) {
if ($scheme === $requiredScheme) {
$schemeMatched = true;
break;
}
}
if (!$schemeMatched) {
$referenceType = self::ABSOLUTE_URL;
$scheme = current($requiredSchemes);
}
} elseif (isset($requirements[&#039;_scheme&#039;]) &amp;&amp; ($req = strtolower($requirements[&#039;_scheme&#039;])) &amp;&amp; $scheme !== $req) {
$referenceType = self::ABSOLUTE_URL;
$scheme = $req;
}
if ($hostTokens) {
$routeHost =&#039;&#039;;
foreach ($hostTokens as $token) {
if (&#039;variable&#039;=== $token[0]) {
if (null !== $this-&gt;strictRequirements &amp;&amp; !preg_match(&#039;#^&#039;.$token[2].&#039;$#i&#039;, $mergedParams[$token[3]])) {
$message = sprintf(&#039;Parameter &quot;%s&quot; for route &quot;%s&quot; must match &quot;%s&quot; (&quot;%s&quot; given) to generate a corresponding URL.&#039;, $token[3], $name, $token[2], $mergedParams[$token[3]]);
if ($this-&gt;strictRequirements) {
throw new InvalidParameterException($message);
}
if ($this-&gt;logger) {
$this-&gt;logger-&gt;error($message);
}
return;
}
$routeHost = $token[1].$mergedParams[$token[3]].$routeHost;
} else {
$routeHost = $token[1].$routeHost;
}
}
if ($routeHost !== $host) {
$host = $routeHost;
if (self::ABSOLUTE_URL !== $referenceType) {
$referenceType = self::NETWORK_PATH;
}
}
}
if (self::ABSOLUTE_URL === $referenceType || self::NETWORK_PATH === $referenceType) {
$port =&#039;&#039;;
if (&#039;http&#039;=== $scheme &amp;&amp; 80 != $this-&gt;context-&gt;getHttpPort()) {
$port =&#039;:&#039;.$this-&gt;context-&gt;getHttpPort();
} elseif (&#039;https&#039;=== $scheme &amp;&amp; 443 != $this-&gt;context-&gt;getHttpsPort()) {
$port =&#039;:&#039;.$this-&gt;context-&gt;getHttpsPort();
}
$schemeAuthority = self::NETWORK_PATH === $referenceType ?&#039;//&#039;: &quot;$scheme://&quot;;
$schemeAuthority .= $host.$port;
}
}
if (self::RELATIVE_PATH === $referenceType) {
$url = self::getRelativePath($this-&gt;context-&gt;getPathInfo(), $url);
} else {
$url = $schemeAuthority.$this-&gt;context-&gt;getBaseUrl().$url;
}
$extra = array_diff_key($parameters, $variables, $defaults);
if ($extra &amp;&amp; $query = http_build_query($extra,&#039;&#039;,&#039;&amp;&#039;)) {
$url .=&#039;?&#039;.strtr($query, array(&#039;%2F&#039;=&gt;&#039;/&#039;));
}
return $url;
}
public static function getRelativePath($basePath, $targetPath)
{
if ($basePath === $targetPath) {
return&#039;&#039;;
}
$sourceDirs = explode(&#039;/&#039;, isset($basePath[0]) &amp;&amp;&#039;/&#039;=== $basePath[0] ? substr($basePath, 1) : $basePath);
$targetDirs = explode(&#039;/&#039;, isset($targetPath[0]) &amp;&amp;&#039;/&#039;=== $targetPath[0] ? substr($targetPath, 1) : $targetPath);
array_pop($sourceDirs);
$targetFile = array_pop($targetDirs);
foreach ($sourceDirs as $i =&gt; $dir) {
if (isset($targetDirs[$i]) &amp;&amp; $dir === $targetDirs[$i]) {
unset($sourceDirs[$i], $targetDirs[$i]);
} else {
break;
}
}
$targetDirs[] = $targetFile;
$path = str_repeat(&#039;../&#039;, count($sourceDirs)).implode(&#039;/&#039;, $targetDirs);
return&#039;&#039;=== $path ||&#039;/&#039;=== $path[0]
|| false !== ($colonPos = strpos($path,&#039;:&#039;)) &amp;&amp; ($colonPos &lt; ($slashPos = strpos($path,&#039;/&#039;)) || false === $slashPos)
? &quot;./$path&quot; : $path;
}
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\HttpFoundation\Request;
class RequestContext
{
private $baseUrl;
private $pathInfo;
private $method;
private $host;
private $scheme;
private $httpPort;
private $httpsPort;
private $queryString;
private $parameters = array();
public function __construct($baseUrl =&#039;&#039;, $method =&#039;GET&#039;, $host =&#039;localhost&#039;, $scheme =&#039;http&#039;, $httpPort = 80, $httpsPort = 443, $path =&#039;/&#039;, $queryString =&#039;&#039;)
{
$this-&gt;setBaseUrl($baseUrl);
$this-&gt;setMethod($method);
$this-&gt;setHost($host);
$this-&gt;setScheme($scheme);
$this-&gt;setHttpPort($httpPort);
$this-&gt;setHttpsPort($httpsPort);
$this-&gt;setPathInfo($path);
$this-&gt;setQueryString($queryString);
}
public function fromRequest(Request $request)
{
$this-&gt;setBaseUrl($request-&gt;getBaseUrl());
$this-&gt;setPathInfo($request-&gt;getPathInfo());
$this-&gt;setMethod($request-&gt;getMethod());
$this-&gt;setHost($request-&gt;getHost());
$this-&gt;setScheme($request-&gt;getScheme());
$this-&gt;setHttpPort($request-&gt;isSecure() ? $this-&gt;httpPort : $request-&gt;getPort());
$this-&gt;setHttpsPort($request-&gt;isSecure() ? $request-&gt;getPort() : $this-&gt;httpsPort);
$this-&gt;setQueryString($request-&gt;server-&gt;get(&#039;QUERY_STRING&#039;,&#039;&#039;));
return $this;
}
public function getBaseUrl()
{
return $this-&gt;baseUrl;
}
public function setBaseUrl($baseUrl)
{
$this-&gt;baseUrl = $baseUrl;
return $this;
}
public function getPathInfo()
{
return $this-&gt;pathInfo;
}
public function setPathInfo($pathInfo)
{
$this-&gt;pathInfo = $pathInfo;
return $this;
}
public function getMethod()
{
return $this-&gt;method;
}
public function setMethod($method)
{
$this-&gt;method = strtoupper($method);
return $this;
}
public function getHost()
{
return $this-&gt;host;
}
public function setHost($host)
{
$this-&gt;host = strtolower($host);
return $this;
}
public function getScheme()
{
return $this-&gt;scheme;
}
public function setScheme($scheme)
{
$this-&gt;scheme = strtolower($scheme);
return $this;
}
public function getHttpPort()
{
return $this-&gt;httpPort;
}
public function setHttpPort($httpPort)
{
$this-&gt;httpPort = (int) $httpPort;
return $this;
}
public function getHttpsPort()
{
return $this-&gt;httpsPort;
}
public function setHttpsPort($httpsPort)
{
$this-&gt;httpsPort = (int) $httpsPort;
return $this;
}
public function getQueryString()
{
return $this-&gt;queryString;
}
public function setQueryString($queryString)
{
$this-&gt;queryString = (string) $queryString;
return $this;
}
public function getParameters()
{
return $this-&gt;parameters;
}
public function setParameters(array $parameters)
{
$this-&gt;parameters = $parameters;
return $this;
}
public function getParameter($name)
{
return isset($this-&gt;parameters[$name]) ? $this-&gt;parameters[$name] : null;
}
public function hasParameter($name)
{
return array_key_exists($name, $this-&gt;parameters);
}
public function setParameter($name, $parameter)
{
$this-&gt;parameters[$name] = $parameter;
return $this;
}
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\RequestContextAwareInterface;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
interface UrlMatcherInterface extends RequestContextAwareInterface
{
public function match($pathinfo);
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
interface RouterInterface extends UrlMatcherInterface, UrlGeneratorInterface
{
public function getRouteCollection();
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
interface RequestMatcherInterface
{
public function matchRequest(Request $request);
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\Config\Loader\LoaderInterface;
use Symfony\Component\Config\ConfigCacheInterface;
use Symfony\Component\Config\ConfigCacheFactoryInterface;
use Symfony\Component\Config\ConfigCacheFactory;
use Psr\Log\LoggerInterface;
use Symfony\Component\Routing\Generator\ConfigurableRequirementsInterface;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Routing\Generator\Dumper\GeneratorDumperInterface;
use Symfony\Component\Routing\Matcher\RequestMatcherInterface;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
use Symfony\Component\Routing\Matcher\Dumper\MatcherDumperInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\ExpressionLanguage\ExpressionFunctionProviderInterface;
class Router implements RouterInterface, RequestMatcherInterface
{
protected $matcher;
protected $generator;
protected $context;
protected $loader;
protected $collection;
protected $resource;
protected $options = array();
protected $logger;
private $configCacheFactory;
private $expressionLanguageProviders = array();
public function __construct(LoaderInterface $loader, $resource, array $options = array(), RequestContext $context = null, LoggerInterface $logger = null)
{
$this-&gt;loader = $loader;
$this-&gt;resource = $resource;
$this-&gt;logger = $logger;
$this-&gt;context = $context ?: new RequestContext();
$this-&gt;setOptions($options);
}
public function setOptions(array $options)
{
$this-&gt;options = array(&#039;cache_dir&#039;=&gt; null,&#039;debug&#039;=&gt; false,&#039;generator_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\UrlGenerator&#039;,&#039;generator_base_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\UrlGenerator&#039;,&#039;generator_dumper_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\Dumper\\PhpGeneratorDumper&#039;,&#039;generator_cache_class&#039;=&gt;&#039;ProjectUrlGenerator&#039;,&#039;matcher_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\UrlMatcher&#039;,&#039;matcher_base_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\UrlMatcher&#039;,&#039;matcher_dumper_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\Dumper\\PhpMatcherDumper&#039;,&#039;matcher_cache_class&#039;=&gt;&#039;ProjectUrlMatcher&#039;,&#039;resource_type&#039;=&gt; null,&#039;strict_requirements&#039;=&gt; true,
);
$invalid = array();
foreach ($options as $key =&gt; $value) {
if (array_key_exists($key, $this-&gt;options)) {
$this-&gt;options[$key] = $value;
} else {
$invalid[] = $key;
}
}
if ($invalid) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the following options: &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, $invalid)));
}
}
public function setOption($key, $value)
{
if (!array_key_exists($key, $this-&gt;options)) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the &quot;%s&quot; option.&#039;, $key));
}
$this-&gt;options[$key] = $value;
}
public function getOption($key)
{
if (!array_key_exists($key, $this-&gt;options)) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the &quot;%s&quot; option.&#039;, $key));
}
return $this-&gt;options[$key];
}
public function getRouteCollection()
{
if (null === $this-&gt;collection) {
$this-&gt;collection = $this-&gt;loader-&gt;load($this-&gt;resource, $this-&gt;options[&#039;resource_type&#039;]);
}
return $this-&gt;collection;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
if (null !== $this-&gt;matcher) {
$this-&gt;getMatcher()-&gt;setContext($context);
}
if (null !== $this-&gt;generator) {
$this-&gt;getGenerator()-&gt;setContext($context);
}
}
public function getContext()
{
return $this-&gt;context;
}
public function setConfigCacheFactory(ConfigCacheFactoryInterface $configCacheFactory)
{
$this-&gt;configCacheFactory = $configCacheFactory;
}
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH)
{
return $this-&gt;getGenerator()-&gt;generate($name, $parameters, $referenceType);
}
public function match($pathinfo)
{
return $this-&gt;getMatcher()-&gt;match($pathinfo);
}
public function matchRequest(Request $request)
{
$matcher = $this-&gt;getMatcher();
if (!$matcher instanceof RequestMatcherInterface) {
return $matcher-&gt;match($request-&gt;getPathInfo());
}
return $matcher-&gt;matchRequest($request);
}
public function getMatcher()
{
if (null !== $this-&gt;matcher) {
return $this-&gt;matcher;
}
if (null === $this-&gt;options[&#039;cache_dir&#039;] || null === $this-&gt;options[&#039;matcher_cache_class&#039;]) {
$this-&gt;matcher = new $this-&gt;options[&#039;matcher_class&#039;]($this-&gt;getRouteCollection(), $this-&gt;context);
if (method_exists($this-&gt;matcher,&#039;addExpressionLanguageProvider&#039;)) {
foreach ($this-&gt;expressionLanguageProviders as $provider) {
$this-&gt;matcher-&gt;addExpressionLanguageProvider($provider);
}
}
return $this-&gt;matcher;
}
$class = $this-&gt;options[&#039;matcher_cache_class&#039;];
$baseClass = $this-&gt;options[&#039;matcher_base_class&#039;];
$expressionLanguageProviders = $this-&gt;expressionLanguageProviders;
$that = $this;
$cache = $this-&gt;getConfigCacheFactory()-&gt;cache($this-&gt;options[&#039;cache_dir&#039;].&#039;/&#039;.$class.&#039;.php&#039;,
function (ConfigCacheInterface $cache) use ($that, $class, $baseClass, $expressionLanguageProviders) {
$dumper = $that-&gt;getMatcherDumperInstance();
if (method_exists($dumper,&#039;addExpressionLanguageProvider&#039;)) {
foreach ($expressionLanguageProviders as $provider) {
$dumper-&gt;addExpressionLanguageProvider($provider);
}
}
$options = array(&#039;class&#039;=&gt; $class,&#039;base_class&#039;=&gt; $baseClass,
);
$cache-&gt;write($dumper-&gt;dump($options), $that-&gt;getRouteCollection()-&gt;getResources());
}
);
require_once $cache-&gt;getPath();
return $this-&gt;matcher = new $class($this-&gt;context);
}
public function getGenerator()
{
if (null !== $this-&gt;generator) {
return $this-&gt;generator;
}
if (null === $this-&gt;options[&#039;cache_dir&#039;] || null === $this-&gt;options[&#039;generator_cache_class&#039;]) {
$this-&gt;generator = new $this-&gt;options[&#039;generator_class&#039;]($this-&gt;getRouteCollection(), $this-&gt;context, $this-&gt;logger);
} else {
$class = $this-&gt;options[&#039;generator_cache_class&#039;];
$baseClass = $this-&gt;options[&#039;generator_base_class&#039;];
$that = $this; $cache = $this-&gt;getConfigCacheFactory()-&gt;cache($this-&gt;options[&#039;cache_dir&#039;].&#039;/&#039;.$class.&#039;.php&#039;,
function (ConfigCacheInterface $cache) use ($that, $class, $baseClass) {
$dumper = $that-&gt;getGeneratorDumperInstance();
$options = array(&#039;class&#039;=&gt; $class,&#039;base_class&#039;=&gt; $baseClass,
);
$cache-&gt;write($dumper-&gt;dump($options), $that-&gt;getRouteCollection()-&gt;getResources());
}
);
require_once $cache-&gt;getPath();
$this-&gt;generator = new $class($this-&gt;context, $this-&gt;logger);
}
if ($this-&gt;generator instanceof ConfigurableRequirementsInterface) {
$this-&gt;generator-&gt;setStrictRequirements($this-&gt;options[&#039;strict_requirements&#039;]);
}
return $this-&gt;generator;
}
public function addExpressionLanguageProvider(ExpressionFunctionProviderInterface $provider)
{
$this-&gt;expressionLanguageProviders[] = $provider;
}
public function getGeneratorDumperInstance()
{
return new $this-&gt;options[&#039;generator_dumper_class&#039;]($this-&gt;getRouteCollection());
}
public function getMatcherDumperInstance()
{
return new $this-&gt;options[&#039;matcher_dumper_class&#039;]($this-&gt;getRouteCollection());
}
private function getConfigCacheFactory()
{
if (null === $this-&gt;configCacheFactory) {
$this-&gt;configCacheFactory = new ConfigCacheFactory($this-&gt;options[&#039;debug&#039;]);
}
return $this-&gt;configCacheFactory;
}
}
}
namespace Symfony\Component\Routing\Matcher
{
interface RedirectableUrlMatcherInterface
{
public function redirect($path, $route, $scheme = null);
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\Route;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
use Symfony\Component\ExpressionLanguage\ExpressionFunctionProviderInterface;
class UrlMatcher implements UrlMatcherInterface, RequestMatcherInterface
{
const REQUIREMENT_MATCH = 0;
const REQUIREMENT_MISMATCH = 1;
const ROUTE_MATCH = 2;
protected $context;
protected $allow = array();
protected $routes;
protected $request;
protected $expressionLanguage;
protected $expressionLanguageProviders = array();
public function __construct(RouteCollection $routes, RequestContext $context)
{
$this-&gt;routes = $routes;
$this-&gt;context = $context;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
}
public function getContext()
{
return $this-&gt;context;
}
public function match($pathinfo)
{
$this-&gt;allow = array();
if ($ret = $this-&gt;matchCollection(rawurldecode($pathinfo), $this-&gt;routes)) {
return $ret;
}
throw 0 &lt; count($this-&gt;allow)
? new MethodNotAllowedException(array_unique($this-&gt;allow))
: new ResourceNotFoundException(sprintf(&#039;No routes found for &quot;%s&quot;.&#039;, $pathinfo));
}
public function matchRequest(Request $request)
{
$this-&gt;request = $request;
$ret = $this-&gt;match($request-&gt;getPathInfo());
$this-&gt;request = null;
return $ret;
}
public function addExpressionLanguageProvider(ExpressionFunctionProviderInterface $provider)
{
$this-&gt;expressionLanguageProviders[] = $provider;
}
protected function matchCollection($pathinfo, RouteCollection $routes)
{
foreach ($routes as $name =&gt; $route) {
$compiledRoute = $route-&gt;compile();
if (&#039;&#039;!== $compiledRoute-&gt;getStaticPrefix() &amp;&amp; 0 !== strpos($pathinfo, $compiledRoute-&gt;getStaticPrefix())) {
continue;
}
if (!preg_match($compiledRoute-&gt;getRegex(), $pathinfo, $matches)) {
continue;
}
$hostMatches = array();
if ($compiledRoute-&gt;getHostRegex() &amp;&amp; !preg_match($compiledRoute-&gt;getHostRegex(), $this-&gt;context-&gt;getHost(), $hostMatches)) {
continue;
}
if ($requiredMethods = $route-&gt;getMethods()) {
if (&#039;HEAD&#039;=== $method = $this-&gt;context-&gt;getMethod()) {
$method =&#039;GET&#039;;
}
if (!in_array($method, $requiredMethods)) {
$this-&gt;allow = array_merge($this-&gt;allow, $requiredMethods);
continue;
}
}
$status = $this-&gt;handleRouteRequirements($pathinfo, $name, $route);
if (self::ROUTE_MATCH === $status[0]) {
return $status[1];
}
if (self::REQUIREMENT_MISMATCH === $status[0]) {
continue;
}
return $this-&gt;getAttributes($route, $name, array_replace($matches, $hostMatches));
}
}
protected function getAttributes(Route $route, $name, array $attributes)
{
$attributes[&#039;_route&#039;] = $name;
return $this-&gt;mergeDefaults($attributes, $route-&gt;getDefaults());
}
protected function handleRouteRequirements($pathinfo, $name, Route $route)
{
if ($route-&gt;getCondition() &amp;&amp; !$this-&gt;getExpressionLanguage()-&gt;evaluate($route-&gt;getCondition(), array(&#039;context&#039;=&gt; $this-&gt;context,&#039;request&#039;=&gt; $this-&gt;request))) {
return array(self::REQUIREMENT_MISMATCH, null);
}
$scheme = $this-&gt;context-&gt;getScheme();
$status = $route-&gt;getSchemes() &amp;&amp; !$route-&gt;hasScheme($scheme) ? self::REQUIREMENT_MISMATCH : self::REQUIREMENT_MATCH;
return array($status, null);
}
protected function mergeDefaults($params, $defaults)
{
foreach ($params as $key =&gt; $value) {
if (!is_int($key)) {
$defaults[$key] = $value;
}
}
return $defaults;
}
protected function getExpressionLanguage()
{
if (null === $this-&gt;expressionLanguage) {
if (!class_exists(&#039;Symfony\Component\ExpressionLanguage\ExpressionLanguage&#039;)) {
throw new \RuntimeException(&#039;Unable to use expressions as the Symfony ExpressionLanguage component is not installed.&#039;);
}
$this-&gt;expressionLanguage = new ExpressionLanguage(null, $this-&gt;expressionLanguageProviders);
}
return $this-&gt;expressionLanguage;
}
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Route;
abstract class RedirectableUrlMatcher extends UrlMatcher implements RedirectableUrlMatcherInterface
{
public function match($pathinfo)
{
try {
$parameters = parent::match($pathinfo);
} catch (ResourceNotFoundException $e) {
if (&#039;/&#039;=== substr($pathinfo, -1) || !in_array($this-&gt;context-&gt;getMethod(), array(&#039;HEAD&#039;,&#039;GET&#039;))) {
throw $e;
}
try {
parent::match($pathinfo.&#039;/&#039;);
return $this-&gt;redirect($pathinfo.&#039;/&#039;, null);
} catch (ResourceNotFoundException $e2) {
throw $e;
}
}
return $parameters;
}
protected function handleRouteRequirements($pathinfo, $name, Route $route)
{
if ($route-&gt;getCondition() &amp;&amp; !$this-&gt;getExpressionLanguage()-&gt;evaluate($route-&gt;getCondition(), array(&#039;context&#039;=&gt; $this-&gt;context,&#039;request&#039;=&gt; $this-&gt;request))) {
return array(self::REQUIREMENT_MISMATCH, null);
}
$scheme = $this-&gt;context-&gt;getScheme();
$schemes = $route-&gt;getSchemes();
if ($schemes &amp;&amp; !$route-&gt;hasScheme($scheme)) {
return array(self::ROUTE_MATCH, $this-&gt;redirect($pathinfo, $name, current($schemes)));
}
return array(self::REQUIREMENT_MATCH, null);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Routing
{
use Symfony\Component\Routing\Matcher\RedirectableUrlMatcher as BaseMatcher;
class RedirectableUrlMatcher extends BaseMatcher
{
public function redirect($path, $route, $scheme = null)
{
return array(&#039;_controller&#039;=&gt;&#039;Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController::urlRedirectAction&#039;,&#039;path&#039;=&gt; $path,&#039;permanent&#039;=&gt; true,&#039;scheme&#039;=&gt; $scheme,&#039;httpPort&#039;=&gt; $this-&gt;context-&gt;getHttpPort(),&#039;httpsPort&#039;=&gt; $this-&gt;context-&gt;getHttpsPort(),&#039;_route&#039;=&gt; $route,
);
}
}
}
namespace Symfony\Component\HttpKernel\CacheWarmer
{
interface WarmableInterface
{
public function warmUp($cacheDir);
}
}
namespace Symfony\Bundle\FrameworkBundle\Routing
{
use Symfony\Component\Routing\Router as BaseRouter;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\HttpKernel\CacheWarmer\WarmableInterface;
use Symfony\Component\DependencyInjection\Exception\ParameterNotFoundException;
use Symfony\Component\DependencyInjection\Exception\RuntimeException;
class Router extends BaseRouter implements WarmableInterface
{
private $container;
public function __construct(ContainerInterface $container, $resource, array $options = array(), RequestContext $context = null)
{
$this-&gt;container = $container;
$this-&gt;resource = $resource;
$this-&gt;context = $context ?: new RequestContext();
$this-&gt;setOptions($options);
}
public function getRouteCollection()
{
if (null === $this-&gt;collection) {
$this-&gt;collection = $this-&gt;container-&gt;get(&#039;routing.loader&#039;)-&gt;load($this-&gt;resource, $this-&gt;options[&#039;resource_type&#039;]);
$this-&gt;resolveParameters($this-&gt;collection);
}
return $this-&gt;collection;
}
public function warmUp($cacheDir)
{
$currentDir = $this-&gt;getOption(&#039;cache_dir&#039;);
$this-&gt;setOption(&#039;cache_dir&#039;, $cacheDir);
$this-&gt;getMatcher();
$this-&gt;getGenerator();
$this-&gt;setOption(&#039;cache_dir&#039;, $currentDir);
}
private function resolveParameters(RouteCollection $collection)
{
foreach ($collection as $route) {
foreach ($route-&gt;getDefaults() as $name =&gt; $value) {
$route-&gt;setDefault($name, $this-&gt;resolve($value));
}
foreach ($route-&gt;getRequirements() as $name =&gt; $value) {
if (&#039;_scheme&#039;=== $name ||&#039;_method&#039;=== $name) {
continue; }
$route-&gt;setRequirement($name, $this-&gt;resolve($value));
}
$route-&gt;setPath($this-&gt;resolve($route-&gt;getPath()));
$route-&gt;setHost($this-&gt;resolve($route-&gt;getHost()));
$schemes = array();
foreach ($route-&gt;getSchemes() as $scheme) {
$schemes = array_merge($schemes, explode(&#039;|&#039;, $this-&gt;resolve($scheme)));
}
$route-&gt;setSchemes($schemes);
$methods = array();
foreach ($route-&gt;getMethods() as $method) {
$methods = array_merge($methods, explode(&#039;|&#039;, $this-&gt;resolve($method)));
}
$route-&gt;setMethods($methods);
$route-&gt;setCondition($this-&gt;resolve($route-&gt;getCondition()));
}
}
private function resolve($value)
{
if (is_array($value)) {
foreach ($value as $key =&gt; $val) {
$value[$key] = $this-&gt;resolve($val);
}
return $value;
}
if (!is_string($value)) {
return $value;
}
$container = $this-&gt;container;
$escapedValue = preg_replace_callback(&#039;/%%|%([^%\s]++)%/&#039;, function ($match) use ($container, $value) {
if (!isset($match[1])) {
return&#039;%%&#039;;
}
$resolved = $container-&gt;getParameter($match[1]);
if (is_string($resolved) || is_numeric($resolved)) {
return (string) $resolved;
}
throw new RuntimeException(sprintf(&#039;The container parameter &quot;%s&quot;, used in the route configuration value &quot;%s&quot;, &#039;.&#039;must be a string or numeric, but it is of type %s.&#039;,
$match[1],
$value,
gettype($resolved)
)
);
}, $value);
return str_replace(&#039;%%&#039;,&#039;%&#039;, $escapedValue);
}
}
}
namespace Symfony\Component\Config
{
class FileLocator implements FileLocatorInterface
{
protected $paths;
public function __construct($paths = array())
{
$this-&gt;paths = (array) $paths;
}
public function locate($name, $currentPath = null, $first = true)
{
if (&#039;&#039;== $name) {
throw new \InvalidArgumentException(&#039;An empty file name is not valid to be located.&#039;);
}
if ($this-&gt;isAbsolutePath($name)) {
if (!file_exists($name)) {
throw new \InvalidArgumentException(sprintf(&#039;The file &quot;%s&quot; does not exist.&#039;, $name));
}
return $name;
}
$paths = $this-&gt;paths;
if (null !== $currentPath) {
array_unshift($paths, $currentPath);
}
$paths = array_unique($paths);
$filepaths = array();
foreach ($paths as $path) {
if (file_exists($file = $path.DIRECTORY_SEPARATOR.$name)) {
if (true === $first) {
return $file;
}
$filepaths[] = $file;
}
}
if (!$filepaths) {
throw new \InvalidArgumentException(sprintf(&#039;The file &quot;%s&quot; does not exist (in: %s).&#039;, $name, implode(&#039;, &#039;, $paths)));
}
return $filepaths;
}
private function isAbsolutePath($file)
{
if ($file[0] ===&#039;/&#039;|| $file[0] ===&#039;\\&#039;|| (strlen($file) &gt; 3 &amp;&amp; ctype_alpha($file[0])
&amp;&amp; $file[1] ===&#039;:&#039;&amp;&amp; ($file[2] ===&#039;\\&#039;|| $file[2] ===&#039;/&#039;)
)
|| null !== parse_url($file, PHP_URL_SCHEME)
) {
return true;
}
return false;
}
}
}
namespace Symfony\Component\EventDispatcher
{
class Event
{
private $propagationStopped = false;
private $dispatcher;
private $name;
public function isPropagationStopped()
{
return $this-&gt;propagationStopped;
}
public function stopPropagation()
{
$this-&gt;propagationStopped = true;
}
public function setDispatcher(EventDispatcherInterface $dispatcher)
{
$this-&gt;dispatcher = $dispatcher;
}
public function getDispatcher()
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method is deprecated since version 2.4 and will be removed in 3.0. The event dispatcher instance can be received in the listener call instead.&#039;, E_USER_DEPRECATED);
return $this-&gt;dispatcher;
}
public function getName()
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method is deprecated since version 2.4 and will be removed in 3.0. The event name can be received in the listener call instead.&#039;, E_USER_DEPRECATED);
return $this-&gt;name;
}
public function setName($name)
{
$this-&gt;name = $name;
}
}
}
namespace Symfony\Component\EventDispatcher
{
interface EventDispatcherInterface
{
public function dispatch($eventName, Event $event = null);
public function addListener($eventName, $listener, $priority = 0);
public function addSubscriber(EventSubscriberInterface $subscriber);
public function removeListener($eventName, $listener);
public function removeSubscriber(EventSubscriberInterface $subscriber);
public function getListeners($eventName = null);
public function hasListeners($eventName = null);
}
}
namespace Symfony\Component\EventDispatcher
{
class EventDispatcher implements EventDispatcherInterface
{
private $listeners = array();
private $sorted = array();
public function dispatch($eventName, Event $event = null)
{
if (null === $event) {
$event = new Event();
}
$event-&gt;setDispatcher($this);
$event-&gt;setName($eventName);
if ($listeners = $this-&gt;getListeners($eventName)) {
$this-&gt;doDispatch($listeners, $eventName, $event);
}
return $event;
}
public function getListeners($eventName = null)
{
if (null !== $eventName) {
if (!isset($this-&gt;listeners[$eventName])) {
return array();
}
if (!isset($this-&gt;sorted[$eventName])) {
$this-&gt;sortListeners($eventName);
}
return $this-&gt;sorted[$eventName];
}
foreach ($this-&gt;listeners as $eventName =&gt; $eventListeners) {
if (!isset($this-&gt;sorted[$eventName])) {
$this-&gt;sortListeners($eventName);
}
}
return array_filter($this-&gt;sorted);
}
public function getListenerPriority($eventName, $listener)
{
if (!isset($this-&gt;listeners[$eventName])) {
return;
}
foreach ($this-&gt;listeners[$eventName] as $priority =&gt; $listeners) {
if (false !== ($key = array_search($listener, $listeners, true))) {
return $priority;
}
}
}
public function hasListeners($eventName = null)
{
return (bool) count($this-&gt;getListeners($eventName));
}
public function addListener($eventName, $listener, $priority = 0)
{
$this-&gt;listeners[$eventName][$priority][] = $listener;
unset($this-&gt;sorted[$eventName]);
}
public function removeListener($eventName, $listener)
{
if (!isset($this-&gt;listeners[$eventName])) {
return;
}
foreach ($this-&gt;listeners[$eventName] as $priority =&gt; $listeners) {
if (false !== ($key = array_search($listener, $listeners, true))) {
unset($this-&gt;listeners[$eventName][$priority][$key], $this-&gt;sorted[$eventName]);
}
}
}
public function addSubscriber(EventSubscriberInterface $subscriber)
{
foreach ($subscriber-&gt;getSubscribedEvents() as $eventName =&gt; $params) {
if (is_string($params)) {
$this-&gt;addListener($eventName, array($subscriber, $params));
} elseif (is_string($params[0])) {
$this-&gt;addListener($eventName, array($subscriber, $params[0]), isset($params[1]) ? $params[1] : 0);
} else {
foreach ($params as $listener) {
$this-&gt;addListener($eventName, array($subscriber, $listener[0]), isset($listener[1]) ? $listener[1] : 0);
}
}
}
}
public function removeSubscriber(EventSubscriberInterface $subscriber)
{
foreach ($subscriber-&gt;getSubscribedEvents() as $eventName =&gt; $params) {
if (is_array($params) &amp;&amp; is_array($params[0])) {
foreach ($params as $listener) {
$this-&gt;removeListener($eventName, array($subscriber, $listener[0]));
}
} else {
$this-&gt;removeListener($eventName, array($subscriber, is_string($params) ? $params : $params[0]));
}
}
}
protected function doDispatch($listeners, $eventName, Event $event)
{
foreach ($listeners as $listener) {
call_user_func($listener, $event, $eventName, $this);
if ($event-&gt;isPropagationStopped()) {
break;
}
}
}
private function sortListeners($eventName)
{
krsort($this-&gt;listeners[$eventName]);
$this-&gt;sorted[$eventName] = call_user_func_array(&#039;array_merge&#039;, $this-&gt;listeners[$eventName]);
}
}
}
namespace Symfony\Component\EventDispatcher
{
use Symfony\Component\DependencyInjection\ContainerInterface;
class ContainerAwareEventDispatcher extends EventDispatcher
{
private $container;
private $listenerIds = array();
private $listeners = array();
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function addListenerService($eventName, $callback, $priority = 0)
{
if (!is_array($callback) || 2 !== count($callback)) {
throw new \InvalidArgumentException(&#039;Expected an array(&quot;service&quot;, &quot;method&quot;) argument&#039;);
}
$this-&gt;listenerIds[$eventName][] = array($callback[0], $callback[1], $priority);
}
public function removeListener($eventName, $listener)
{
$this-&gt;lazyLoad($eventName);
if (isset($this-&gt;listenerIds[$eventName])) {
foreach ($this-&gt;listenerIds[$eventName] as $i =&gt; $args) {
list($serviceId, $method, $priority) = $args;
$key = $serviceId.&#039;.&#039;.$method;
if (isset($this-&gt;listeners[$eventName][$key]) &amp;&amp; $listener === array($this-&gt;listeners[$eventName][$key], $method)) {
unset($this-&gt;listeners[$eventName][$key]);
if (empty($this-&gt;listeners[$eventName])) {
unset($this-&gt;listeners[$eventName]);
}
unset($this-&gt;listenerIds[$eventName][$i]);
if (empty($this-&gt;listenerIds[$eventName])) {
unset($this-&gt;listenerIds[$eventName]);
}
}
}
}
parent::removeListener($eventName, $listener);
}
public function hasListeners($eventName = null)
{
if (null === $eventName) {
return (bool) count($this-&gt;listenerIds) || (bool) count($this-&gt;listeners);
}
if (isset($this-&gt;listenerIds[$eventName])) {
return true;
}
return parent::hasListeners($eventName);
}
public function getListeners($eventName = null)
{
if (null === $eventName) {
foreach ($this-&gt;listenerIds as $serviceEventName =&gt; $args) {
$this-&gt;lazyLoad($serviceEventName);
}
} else {
$this-&gt;lazyLoad($eventName);
}
return parent::getListeners($eventName);
}
public function getListenerPriority($eventName, $listener)
{
$this-&gt;lazyLoad($eventName);
return parent::getListenerPriority($eventName, $listener);
}
public function addSubscriberService($serviceId, $class)
{
foreach ($class::getSubscribedEvents() as $eventName =&gt; $params) {
if (is_string($params)) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $params, 0);
} elseif (is_string($params[0])) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $params[0], isset($params[1]) ? $params[1] : 0);
} else {
foreach ($params as $listener) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $listener[0], isset($listener[1]) ? $listener[1] : 0);
}
}
}
}
public function getContainer()
{
return $this-&gt;container;
}
protected function lazyLoad($eventName)
{
if (isset($this-&gt;listenerIds[$eventName])) {
foreach ($this-&gt;listenerIds[$eventName] as $args) {
list($serviceId, $method, $priority) = $args;
$listener = $this-&gt;container-&gt;get($serviceId);
$key = $serviceId.&#039;.&#039;.$method;
if (!isset($this-&gt;listeners[$eventName][$key])) {
$this-&gt;addListener($eventName, array($listener, $method), $priority);
} elseif ($listener !== $this-&gt;listeners[$eventName][$key]) {
parent::removeListener($eventName, array($this-&gt;listeners[$eventName][$key], $method));
$this-&gt;addListener($eventName, array($listener, $method), $priority);
}
$this-&gt;listeners[$eventName][$key] = $listener;
}
}
}
}
}
namespace Symfony\Component\HttpKernel\EventListener
{
use Symfony\Component\HttpKernel\Event\FilterResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class ResponseListener implements EventSubscriberInterface
{
private $charset;
public function __construct($charset)
{
$this-&gt;charset = $charset;
}
public function onKernelResponse(FilterResponseEvent $event)
{
if (!$event-&gt;isMasterRequest()) {
return;
}
$response = $event-&gt;getResponse();
if (null === $response-&gt;getCharset()) {
$response-&gt;setCharset($this-&gt;charset);
}
$response-&gt;prepare($event-&gt;getRequest());
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::RESPONSE =&gt;&#039;onKernelResponse&#039;,
);
}
}
}
namespace Symfony\Component\HttpKernel\EventListener
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\HttpKernel\Event\FinishRequestEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpFoundation\RequestStack;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
use Symfony\Component\Routing\Matcher\RequestMatcherInterface;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\RequestContextAwareInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpFoundation\Request;
class RouterListener implements EventSubscriberInterface
{
private $matcher;
private $context;
private $logger;
private $request;
private $requestStack;
public function __construct($matcher, $requestStack = null, $context = null, $logger = null)
{
if ($requestStack instanceof RequestContext || $context instanceof LoggerInterface || $logger instanceof RequestStack) {
$tmp = $requestStack;
$requestStack = $logger;
$logger = $context;
$context = $tmp;
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method now requires a RequestStack to be given as second argument as &#039;.__CLASS__.&#039;::setRequest method will not be supported anymore in 3.0.&#039;, E_USER_DEPRECATED);
} elseif (!$requestStack instanceof RequestStack) {
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method now requires a RequestStack instance as &#039;.__CLASS__.&#039;::setRequest method will not be supported anymore in 3.0.&#039;, E_USER_DEPRECATED);
}
if (null !== $requestStack &amp;&amp; !$requestStack instanceof RequestStack) {
throw new \InvalidArgumentException(&#039;RequestStack instance expected.&#039;);
}
if (null !== $context &amp;&amp; !$context instanceof RequestContext) {
throw new \InvalidArgumentException(&#039;RequestContext instance expected.&#039;);
}
if (null !== $logger &amp;&amp; !$logger instanceof LoggerInterface) {
throw new \InvalidArgumentException(&#039;Logger must implement LoggerInterface.&#039;);
}
if (!$matcher instanceof UrlMatcherInterface &amp;&amp; !$matcher instanceof RequestMatcherInterface) {
throw new \InvalidArgumentException(&#039;Matcher must either implement UrlMatcherInterface or RequestMatcherInterface.&#039;);
}
if (null === $context &amp;&amp; !$matcher instanceof RequestContextAwareInterface) {
throw new \InvalidArgumentException(&#039;You must either pass a RequestContext or the matcher must implement RequestContextAwareInterface.&#039;);
}
$this-&gt;matcher = $matcher;
$this-&gt;context = $context ?: $matcher-&gt;getContext();
$this-&gt;requestStack = $requestStack;
$this-&gt;logger = $logger;
}
public function setRequest(Request $request = null)
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method is deprecated since version 2.4 and will be made private in 3.0.&#039;, E_USER_DEPRECATED);
$this-&gt;setCurrentRequest($request);
}
private function setCurrentRequest(Request $request = null)
{
if (null !== $request &amp;&amp; $this-&gt;request !== $request) {
$this-&gt;context-&gt;fromRequest($request);
}
$this-&gt;request = $request;
}
public function onKernelFinishRequest(FinishRequestEvent $event)
{
if (null === $this-&gt;requestStack) {
return; }
$this-&gt;setCurrentRequest($this-&gt;requestStack-&gt;getParentRequest());
}
public function onKernelRequest(GetResponseEvent $event)
{
$request = $event-&gt;getRequest();
if (null !== $this-&gt;requestStack) {
$this-&gt;setCurrentRequest($request);
}
if ($request-&gt;attributes-&gt;has(&#039;_controller&#039;)) {
return;
}
try {
if ($this-&gt;matcher instanceof RequestMatcherInterface) {
$parameters = $this-&gt;matcher-&gt;matchRequest($request);
} else {
$parameters = $this-&gt;matcher-&gt;match($request-&gt;getPathInfo());
}
if (null !== $this-&gt;logger) {
$this-&gt;logger-&gt;info(sprintf(&#039;Matched route &quot;%s&quot;.&#039;, isset($parameters[&#039;_route&#039;]) ? $parameters[&#039;_route&#039;] :&#039;n/a&#039;), array(&#039;route_parameters&#039;=&gt; $parameters,&#039;request_uri&#039;=&gt; $request-&gt;getUri(),
));
}
$request-&gt;attributes-&gt;add($parameters);
unset($parameters[&#039;_route&#039;], $parameters[&#039;_controller&#039;]);
$request-&gt;attributes-&gt;set(&#039;_route_params&#039;, $parameters);
} catch (ResourceNotFoundException $e) {
$message = sprintf(&#039;No route found for &quot;%s %s&quot;&#039;, $request-&gt;getMethod(), $request-&gt;getPathInfo());
if ($referer = $request-&gt;headers-&gt;get(&#039;referer&#039;)) {
$message .= sprintf(&#039; (from &quot;%s&quot;)&#039;, $referer);
}
throw new NotFoundHttpException($message, $e);
} catch (MethodNotAllowedException $e) {
$message = sprintf(&#039;No route found for &quot;%s %s&quot;: Method Not Allowed (Allow: %s)&#039;, $request-&gt;getMethod(), $request-&gt;getPathInfo(), implode(&#039;, &#039;, $e-&gt;getAllowedMethods()));
throw new MethodNotAllowedHttpException($e-&gt;getAllowedMethods(), $message, $e);
}
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::REQUEST =&gt; array(array(&#039;onKernelRequest&#039;, 32)),
KernelEvents::FINISH_REQUEST =&gt; array(array(&#039;onKernelFinishRequest&#039;, 0)),
);
}
}
}
namespace Symfony\Component\HttpKernel\Controller
{
use Symfony\Component\HttpFoundation\Request;
interface ControllerResolverInterface
{
public function getController(Request $request);
public function getArguments(Request $request, $controller);
}
}
namespace Symfony\Component\HttpKernel\Controller
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpFoundation\Request;
class ControllerResolver implements ControllerResolverInterface
{
private $logger;
public function __construct(LoggerInterface $logger = null)
{
$this-&gt;logger = $logger;
}
public function getController(Request $request)
{
if (!$controller = $request-&gt;attributes-&gt;get(&#039;_controller&#039;)) {
if (null !== $this-&gt;logger) {
$this-&gt;logger-&gt;warning(&#039;Unable to look for the controller as the &quot;_controller&quot; parameter is missing.&#039;);
}
return false;
}
if (is_array($controller)) {
return $controller;
}
if (is_object($controller)) {
if (method_exists($controller,&#039;__invoke&#039;)) {
return $controller;
}
throw new \InvalidArgumentException(sprintf(&#039;Controller &quot;%s&quot; for URI &quot;%s&quot; is not callable.&#039;, get_class($controller), $request-&gt;getPathInfo()));
}
if (false === strpos($controller,&#039;:&#039;)) {
if (method_exists($controller,&#039;__invoke&#039;)) {
return $this-&gt;instantiateController($controller);
} elseif (function_exists($controller)) {
return $controller;
}
}
$callable = $this-&gt;createController($controller);
if (!is_callable($callable)) {
throw new \InvalidArgumentException(sprintf(&#039;Controller &quot;%s&quot; for URI &quot;%s&quot; is not callable.&#039;, $controller, $request-&gt;getPathInfo()));
}
return $callable;
}
public function getArguments(Request $request, $controller)
{
if (is_array($controller)) {
$r = new \ReflectionMethod($controller[0], $controller[1]);
} elseif (is_object($controller) &amp;&amp; !$controller instanceof \Closure) {
$r = new \ReflectionObject($controller);
$r = $r-&gt;getMethod(&#039;__invoke&#039;);
} else {
$r = new \ReflectionFunction($controller);
}
return $this-&gt;doGetArguments($request, $controller, $r-&gt;getParameters());
}
protected function doGetArguments(Request $request, $controller, array $parameters)
{
$attributes = $request-&gt;attributes-&gt;all();
$arguments = array();
foreach ($parameters as $param) {
if (array_key_exists($param-&gt;name, $attributes)) {
$arguments[] = $attributes[$param-&gt;name];
} elseif ($param-&gt;getClass() &amp;&amp; $param-&gt;getClass()-&gt;isInstance($request)) {
$arguments[] = $request;
} elseif ($param-&gt;isDefaultValueAvailable()) {
$arguments[] = $param-&gt;getDefaultValue();
} else {
if (is_array($controller)) {
$repr = sprintf(&#039;%s::%s()&#039;, get_class($controller[0]), $controller[1]);
} elseif (is_object($controller)) {
$repr = get_class($controller);
} else {
$repr = $controller;
}
throw new \RuntimeException(sprintf(&#039;Controller &quot;%s&quot; requires that you provide a value for the &quot;$%s&quot; argument (because there is no default value or because there is a non optional argument after this one).&#039;, $repr, $param-&gt;name));
}
}
return $arguments;
}
protected function createController($controller)
{
if (false === strpos($controller,&#039;::&#039;)) {
throw new \InvalidArgumentException(sprintf(&#039;Unable to find controller &quot;%s&quot;.&#039;, $controller));
}
list($class, $method) = explode(&#039;::&#039;, $controller, 2);
if (!class_exists($class)) {
throw new \InvalidArgumentException(sprintf(&#039;Class &quot;%s&quot; does not exist.&#039;, $class));
}
return array($this-&gt;instantiateController($class), $method);
}
protected function instantiateController($class)
{
return new $class();
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\EventDispatcher\Event;
class KernelEvent extends Event
{
private $kernel;
private $request;
private $requestType;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType)
{
$this-&gt;kernel = $kernel;
$this-&gt;request = $request;
$this-&gt;requestType = $requestType;
}
public function getKernel()
{
return $this-&gt;kernel;
}
public function getRequest()
{
return $this-&gt;request;
}
public function getRequestType()
{
return $this-&gt;requestType;
}
public function isMasterRequest()
{
return HttpKernelInterface::MASTER_REQUEST === $this-&gt;requestType;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class FilterControllerEvent extends KernelEvent
{
private $controller;
public function __construct(HttpKernelInterface $kernel, $controller, Request $request, $requestType)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setController($controller);
}
public function getController()
{
return $this-&gt;controller;
}
public function setController($controller)
{
if (!is_callable($controller)) {
throw new \LogicException(sprintf(&#039;The controller must be a callable (%s given).&#039;, $this-&gt;varToString($controller)));
}
$this-&gt;controller = $controller;
}
private function varToString($var)
{
if (is_object($var)) {
return sprintf(&#039;Object(%s)&#039;, get_class($var));
}
if (is_array($var)) {
$a = array();
foreach ($var as $k =&gt; $v) {
$a[] = sprintf(&#039;%s =&gt; %s&#039;, $k, $this-&gt;varToString($v));
}
return sprintf(&#039;Array(%s)&#039;, implode(&#039;, &#039;, $a));
}
if (is_resource($var)) {
return sprintf(&#039;Resource(%s)&#039;, get_resource_type($var));
}
if (null === $var) {
return&#039;null&#039;;
}
if (false === $var) {
return&#039;false&#039;;
}
if (true === $var) {
return&#039;true&#039;;
}
return (string) $var;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
class FilterResponseEvent extends KernelEvent
{
private $response;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, Response $response)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setResponse($response);
}
public function getResponse()
{
return $this-&gt;response;
}
public function setResponse(Response $response)
{
$this-&gt;response = $response;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpFoundation\Response;
class GetResponseEvent extends KernelEvent
{
private $response;
public function getResponse()
{
return $this-&gt;response;
}
public function setResponse(Response $response)
{
$this-&gt;response = $response;
$this-&gt;stopPropagation();
}
public function hasResponse()
{
return null !== $this-&gt;response;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class GetResponseForControllerResultEvent extends GetResponseEvent
{
private $controllerResult;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, $controllerResult)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;controllerResult = $controllerResult;
}
public function getControllerResult()
{
return $this-&gt;controllerResult;
}
public function setControllerResult($controllerResult)
{
$this-&gt;controllerResult = $controllerResult;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class GetResponseForExceptionEvent extends GetResponseEvent
{
private $exception;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, \Exception $e)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setException($e);
}
public function getException()
{
return $this-&gt;exception;
}
public function setException(\Exception $exception)
{
$this-&gt;exception = $exception;
}
}
}
namespace Symfony\Component\HttpKernel
{
final class KernelEvents
{
const REQUEST =&#039;kernel.request&#039;;
const EXCEPTION =&#039;kernel.exception&#039;;
const VIEW =&#039;kernel.view&#039;;
const CONTROLLER =&#039;kernel.controller&#039;;
const RESPONSE =&#039;kernel.response&#039;;
const TERMINATE =&#039;kernel.terminate&#039;;
const FINISH_REQUEST =&#039;kernel.finish_request&#039;;
}
}
namespace Symfony\Component\HttpKernel\Config
{
use Symfony\Component\Config\FileLocator as BaseFileLocator;
use Symfony\Component\HttpKernel\KernelInterface;
class FileLocator extends BaseFileLocator
{
private $kernel;
private $path;
public function __construct(KernelInterface $kernel, $path = null, array $paths = array())
{
$this-&gt;kernel = $kernel;
if (null !== $path) {
$this-&gt;path = $path;
$paths[] = $path;
}
parent::__construct($paths);
}
public function locate($file, $currentPath = null, $first = true)
{
if (isset($file[0]) &amp;&amp;&#039;@&#039;=== $file[0]) {
return $this-&gt;kernel-&gt;locateResource($file, $this-&gt;path, $first);
}
return parent::locate($file, $currentPath, $first);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Controller
{
use Symfony\Component\HttpKernel\KernelInterface;
class ControllerNameParser
{
protected $kernel;
public function __construct(KernelInterface $kernel)
{
$this-&gt;kernel = $kernel;
}
public function parse($controller)
{
$originalController = $controller;
if (3 !== count($parts = explode(&#039;:&#039;, $controller))) {
throw new \InvalidArgumentException(sprintf(&#039;The &quot;%s&quot; controller is not a valid &quot;a:b:c&quot; controller string.&#039;, $controller));
}
list($bundle, $controller, $action) = $parts;
$controller = str_replace(&#039;/&#039;,&#039;\\&#039;, $controller);
$bundles = array();
try {
$allBundles = $this-&gt;kernel-&gt;getBundle($bundle, false);
} catch (\InvalidArgumentException $e) {
$message = sprintf(&#039;The &quot;%s&quot; (from the _controller value &quot;%s&quot;) does not exist or is not enabled in your kernel!&#039;,
$bundle,
$originalController
);
if ($alternative = $this-&gt;findAlternative($bundle)) {
$message .= sprintf(&#039; Did you mean &quot;%s:%s:%s&quot;?&#039;, $alternative, $controller, $action);
}
throw new \InvalidArgumentException($message, 0, $e);
}
foreach ($allBundles as $b) {
$try = $b-&gt;getNamespace().&#039;\\Controller\\&#039;.$controller.&#039;Controller&#039;;
if (class_exists($try)) {
return $try.&#039;::&#039;.$action.&#039;Action&#039;;
}
$bundles[] = $b-&gt;getName();
$msg = sprintf(&#039;The _controller value &quot;%s:%s:%s&quot; maps to a &quot;%s&quot; class, but this class was not found. Create this class or check the spelling of the class and its namespace.&#039;, $bundle, $controller, $action, $try);
}
if (count($bundles) &gt; 1) {
$msg = sprintf(&#039;Unable to find controller &quot;%s:%s&quot; in bundles %s.&#039;, $bundle, $controller, implode(&#039;, &#039;, $bundles));
}
throw new \InvalidArgumentException($msg);
}
public function build($controller)
{
if (0 === preg_match(&#039;#^(.*?\\\\Controller\\\\(.+)Controller)::(.+)Action$#&#039;, $controller, $match)) {
throw new \InvalidArgumentException(sprintf(&#039;The &quot;%s&quot; controller is not a valid &quot;class::method&quot; string.&#039;, $controller));
}
$className = $match[1];
$controllerName = $match[2];
$actionName = $match[3];
foreach ($this-&gt;kernel-&gt;getBundles() as $name =&gt; $bundle) {
if (0 !== strpos($className, $bundle-&gt;getNamespace())) {
continue;
}
return sprintf(&#039;%s:%s:%s&#039;, $name, $controllerName, $actionName);
}
throw new \InvalidArgumentException(sprintf(&#039;Unable to find a bundle that defines controller &quot;%s&quot;.&#039;, $controller));
}
private function findAlternative($nonExistentBundleName)
{
$bundleNames = array_map(function ($b) {
return $b-&gt;getName();
}, $this-&gt;kernel-&gt;getBundles());
$alternative = null;
$shortest = null;
foreach ($bundleNames as $bundleName) {
if (false !== strpos($bundleName, $nonExistentBundleName)) {
return $bundleName;
}
$lev = levenshtein($nonExistentBundleName, $bundleName);
if ($lev &lt;= strlen($nonExistentBundleName) / 3 &amp;&amp; ($alternative === null || $lev &lt; $shortest)) {
$alternative = $bundleName;
}
}
return $alternative;
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Controller
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Controller\ControllerResolver as BaseControllerResolver;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\ContainerAwareInterface;
class ControllerResolver extends BaseControllerResolver
{
protected $container;
protected $parser;
public function __construct(ContainerInterface $container, ControllerNameParser $parser, LoggerInterface $logger = null)
{
$this-&gt;container = $container;
$this-&gt;parser = $parser;
parent::__construct($logger);
}
protected function createController($controller)
{
if (false === strpos($controller,&#039;::&#039;)) {
$count = substr_count($controller,&#039;:&#039;);
if (2 == $count) {
$controller = $this-&gt;parser-&gt;parse($controller);
} elseif (1 == $count) {
list($service, $method) = explode(&#039;:&#039;, $controller, 2);
return array($this-&gt;container-&gt;get($service), $method);
} elseif ($this-&gt;container-&gt;has($controller) &amp;&amp; method_exists($service = $this-&gt;container-&gt;get($controller),&#039;__invoke&#039;)) {
return $service;
} else {
throw new \LogicException(sprintf(&#039;Unable to parse the controller name &quot;%s&quot;.&#039;, $controller));
}
}
return parent::createController($controller);
}
protected function instantiateController($class)
{
$controller = parent::instantiateController($class);
if ($controller instanceof ContainerAwareInterface) {
$controller-&gt;setContainer($this-&gt;container);
}
return $controller;
}
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpFoundation\Request;
interface AccessMapInterface
{
public function getPatterns(Request $request);
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpFoundation\RequestMatcherInterface;
use Symfony\Component\HttpFoundation\Request;
class AccessMap implements AccessMapInterface
{
private $map = array();
public function add(RequestMatcherInterface $requestMatcher, array $attributes = array(), $channel = null)
{
$this-&gt;map[] = array($requestMatcher, $attributes, $channel);
}
public function getPatterns(Request $request)
{
foreach ($this-&gt;map as $elements) {
if (null === $elements[0] || $elements[0]-&gt;matches($request)) {
return array($elements[1], $elements[2]);
}
}
return array(null, null);
}
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\HttpKernel\Event\FinishRequestEvent;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class Firewall implements EventSubscriberInterface
{
private $map;
private $dispatcher;
private $exceptionListeners;
public function __construct(FirewallMapInterface $map, EventDispatcherInterface $dispatcher)
{
$this-&gt;map = $map;
$this-&gt;dispatcher = $dispatcher;
$this-&gt;exceptionListeners = new \SplObjectStorage();
}
public function onKernelRequest(GetResponseEvent $event)
{
if (!$event-&gt;isMasterRequest()) {
return;
}
list($listeners, $exceptionListener) = $this-&gt;map-&gt;getListeners($event-&gt;getRequest());
if (null !== $exceptionListener) {
$this-&gt;exceptionListeners[$event-&gt;getRequest()] = $exceptionListener;
$exceptionListener-&gt;register($this-&gt;dispatcher);
}
foreach ($listeners as $listener) {
$listener-&gt;handle($event);
if ($event-&gt;hasResponse()) {
break;
}
}
}
public function onKernelFinishRequest(FinishRequestEvent $event)
{
$request = $event-&gt;getRequest();
if (isset($this-&gt;exceptionListeners[$request])) {
$this-&gt;exceptionListeners[$request]-&gt;unregister($this-&gt;dispatcher);
unset($this-&gt;exceptionListeners[$request]);
}
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::REQUEST =&gt; array(&#039;onKernelRequest&#039;, 8),
KernelEvents::FINISH_REQUEST =&gt;&#039;onKernelFinishRequest&#039;,
);
}
}
}
namespace Symfony\Component\Security\Core\User
{
use Symfony\Component\Security\Core\Exception\UsernameNotFoundException;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
interface UserProviderInterface
{
public function loadUserByUsername($username);
public function refreshUser(UserInterface $user);
public function supportsClass($class);
}
}
namespace Symfony\Component\Security\Core\Authentication
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
interface AuthenticationManagerInterface
{
public function authenticate(TokenInterface $token);
}
}
namespace Symfony\Component\Security\Core\Authentication
{
use Symfony\Component\Security\Core\Event\AuthenticationFailureEvent;
use Symfony\Component\Security\Core\Event\AuthenticationEvent;
use Symfony\Component\Security\Core\AuthenticationEvents;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\Security\Core\Exception\AccountStatusException;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\ProviderNotFoundException;
use Symfony\Component\Security\Core\Authentication\Provider\AuthenticationProviderInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class AuthenticationProviderManager implements AuthenticationManagerInterface
{
private $providers;
private $eraseCredentials;
private $eventDispatcher;
public function __construct(array $providers, $eraseCredentials = true)
{
if (!$providers) {
throw new \InvalidArgumentException(&#039;You must at least add one authentication provider.&#039;);
}
foreach ($providers as $provider) {
if (!$provider instanceof AuthenticationProviderInterface) {
throw new \InvalidArgumentException(sprintf(&#039;Provider &quot;%s&quot; must implement the AuthenticationProviderInterface.&#039;, get_class($provider)));
}
}
$this-&gt;providers = $providers;
$this-&gt;eraseCredentials = (bool) $eraseCredentials;
}
public function setEventDispatcher(EventDispatcherInterface $dispatcher)
{
$this-&gt;eventDispatcher = $dispatcher;
}
public function authenticate(TokenInterface $token)
{
$lastException = null;
$result = null;
foreach ($this-&gt;providers as $provider) {
if (!$provider-&gt;supports($token)) {
continue;
}
try {
$result = $provider-&gt;authenticate($token);
if (null !== $result) {
break;
}
} catch (AccountStatusException $e) {
$e-&gt;setToken($token);
throw $e;
} catch (AuthenticationException $e) {
$lastException = $e;
}
}
if (null !== $result) {
if (true === $this-&gt;eraseCredentials) {
$result-&gt;eraseCredentials();
}
if (null !== $this-&gt;eventDispatcher) {
$this-&gt;eventDispatcher-&gt;dispatch(AuthenticationEvents::AUTHENTICATION_SUCCESS, new AuthenticationEvent($result));
}
return $result;
}
if (null === $lastException) {
$lastException = new ProviderNotFoundException(sprintf(&#039;No Authentication Provider found for token of class &quot;%s&quot;.&#039;, get_class($token)));
}
if (null !== $this-&gt;eventDispatcher) {
$this-&gt;eventDispatcher-&gt;dispatch(AuthenticationEvents::AUTHENTICATION_FAILURE, new AuthenticationFailureEvent($token, $lastException));
}
$lastException-&gt;setToken($token);
throw $lastException;
}
}
}
namespace Symfony\Component\Security\Core\Authentication\Token\Storage
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface TokenStorageInterface
{
public function getToken();
public function setToken(TokenInterface $token = null);
}
}
namespace Symfony\Component\Security\Core\Authentication\Token\Storage
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class TokenStorage implements TokenStorageInterface
{
private $token;
public function getToken()
{
return $this-&gt;token;
}
public function setToken(TokenInterface $token = null)
{
$this-&gt;token = $token;
}
}
}
namespace Symfony\Component\Security\Core\Authorization
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface AccessDecisionManagerInterface
{
public function decide(TokenInterface $token, array $attributes, $object = null);
public function supportsAttribute($attribute);
public function supportsClass($class);
}
}
namespace Symfony\Component\Security\Core\Authorization
{
use Symfony\Component\Security\Core\Authorization\Voter\VoterInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class AccessDecisionManager implements AccessDecisionManagerInterface
{
const STRATEGY_AFFIRMATIVE =&#039;affirmative&#039;;
const STRATEGY_CONSENSUS =&#039;consensus&#039;;
const STRATEGY_UNANIMOUS =&#039;unanimous&#039;;
private $voters;
private $strategy;
private $allowIfAllAbstainDecisions;
private $allowIfEqualGrantedDeniedDecisions;
public function __construct(array $voters = array(), $strategy = self::STRATEGY_AFFIRMATIVE, $allowIfAllAbstainDecisions = false, $allowIfEqualGrantedDeniedDecisions = true)
{
$strategyMethod =&#039;decide&#039;.ucfirst($strategy);
if (!is_callable(array($this, $strategyMethod))) {
throw new \InvalidArgumentException(sprintf(&#039;The strategy &quot;%s&quot; is not supported.&#039;, $strategy));
}
$this-&gt;voters = $voters;
$this-&gt;strategy = $strategyMethod;
$this-&gt;allowIfAllAbstainDecisions = (bool) $allowIfAllAbstainDecisions;
$this-&gt;allowIfEqualGrantedDeniedDecisions = (bool) $allowIfEqualGrantedDeniedDecisions;
}
public function setVoters(array $voters)
{
$this-&gt;voters = $voters;
}
public function decide(TokenInterface $token, array $attributes, $object = null)
{
return $this-&gt;{$this-&gt;strategy}($token, $attributes, $object);
}
public function supportsAttribute($attribute)
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; is deprecated since version 2.8 and will be removed in version 3.0.&#039;, E_USER_DEPRECATED);
foreach ($this-&gt;voters as $voter) {
if ($voter-&gt;supportsAttribute($attribute)) {
return true;
}
}
return false;
}
public function supportsClass($class)
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; is deprecated since version 2.8 and will be removed in version 3.0.&#039;, E_USER_DEPRECATED);
foreach ($this-&gt;voters as $voter) {
if ($voter-&gt;supportsClass($class)) {
return true;
}
}
return false;
}
private function decideAffirmative(TokenInterface $token, array $attributes, $object = null)
{
$deny = 0;
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, $attributes);
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
return true;
case VoterInterface::ACCESS_DENIED:
++$deny;
break;
default:
break;
}
}
if ($deny &gt; 0) {
return false;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
private function decideConsensus(TokenInterface $token, array $attributes, $object = null)
{
$grant = 0;
$deny = 0;
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, $attributes);
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
++$grant;
break;
case VoterInterface::ACCESS_DENIED:
++$deny;
break;
}
}
if ($grant &gt; $deny) {
return true;
}
if ($deny &gt; $grant) {
return false;
}
if ($grant &gt; 0) {
return $this-&gt;allowIfEqualGrantedDeniedDecisions;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
private function decideUnanimous(TokenInterface $token, array $attributes, $object = null)
{
$grant = 0;
foreach ($attributes as $attribute) {
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, array($attribute));
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
++$grant;
break;
case VoterInterface::ACCESS_DENIED:
return false;
default:
break;
}
}
}
if ($grant &gt; 0) {
return true;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
}
}
namespace Symfony\Component\Security\Core\Authorization
{
interface AuthorizationCheckerInterface
{
public function isGranted($attributes, $object = null);
}
}
namespace Symfony\Component\Security\Core\Authorization
{
use Symfony\Component\Security\Core\Authentication\AuthenticationManagerInterface;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationCredentialsNotFoundException;
class AuthorizationChecker implements AuthorizationCheckerInterface
{
private $tokenStorage;
private $accessDecisionManager;
private $authenticationManager;
private $alwaysAuthenticate;
public function __construct(TokenStorageInterface $tokenStorage, AuthenticationManagerInterface $authenticationManager, AccessDecisionManagerInterface $accessDecisionManager, $alwaysAuthenticate = false)
{
$this-&gt;tokenStorage = $tokenStorage;
$this-&gt;authenticationManager = $authenticationManager;
$this-&gt;accessDecisionManager = $accessDecisionManager;
$this-&gt;alwaysAuthenticate = $alwaysAuthenticate;
}
final public function isGranted($attributes, $object = null)
{
if (null === ($token = $this-&gt;tokenStorage-&gt;getToken())) {
throw new AuthenticationCredentialsNotFoundException(&#039;The token storage contains no authentication token. One possible reason may be that there is no firewall configured for this URL.&#039;);
}
if ($this-&gt;alwaysAuthenticate || !$token-&gt;isAuthenticated()) {
$this-&gt;tokenStorage-&gt;setToken($token = $this-&gt;authenticationManager-&gt;authenticate($token));
}
if (!is_array($attributes)) {
$attributes = array($attributes);
}
return $this-&gt;accessDecisionManager-&gt;decide($token, $attributes, $object);
}
}
}
namespace Symfony\Component\Security\Core\Authorization\Voter
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface VoterInterface
{
const ACCESS_GRANTED = 1;
const ACCESS_ABSTAIN = 0;
const ACCESS_DENIED = -1;
public function supportsAttribute($attribute);
public function supportsClass($class);
public function vote(TokenInterface $token, $object, array $attributes);
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpFoundation\Request;
interface FirewallMapInterface
{
public function getListeners(Request $request);
}
}
namespace Symfony\Bundle\SecurityBundle\Security
{
use Symfony\Component\Security\Http\FirewallMapInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\DependencyInjection\ContainerInterface;
class FirewallMap implements FirewallMapInterface
{
protected $container;
protected $map;
public function __construct(ContainerInterface $container, array $map)
{
$this-&gt;container = $container;
$this-&gt;map = $map;
}
public function getListeners(Request $request)
{
foreach ($this-&gt;map as $contextId =&gt; $requestMatcher) {
if (null === $requestMatcher || $requestMatcher-&gt;matches($request)) {
return $this-&gt;container-&gt;get($contextId)-&gt;getContext();
}
}
return array(array(), null);
}
}
}
namespace Symfony\Bundle\SecurityBundle\Security
{
use Symfony\Component\Security\Http\Firewall\ExceptionListener;
class FirewallContext
{
private $listeners;
private $exceptionListener;
public function __construct(array $listeners, ExceptionListener $exceptionListener = null)
{
$this-&gt;listeners = $listeners;
$this-&gt;exceptionListener = $exceptionListener;
}
public function getContext()
{
return array($this-&gt;listeners, $this-&gt;exceptionListener);
}
}
}
namespace Symfony\Component\HttpFoundation
{
interface RequestMatcherInterface
{
public function matches(Request $request);
}
}
namespace Symfony\Component\HttpFoundation
{
class RequestMatcher implements RequestMatcherInterface
{
private $path;
private $host;
private $methods = array();
private $ips = array();
private $attributes = array();
private $schemes = array();
public function __construct($path = null, $host = null, $methods = null, $ips = null, array $attributes = array(), $schemes = null)
{
$this-&gt;matchPath($path);
$this-&gt;matchHost($host);
$this-&gt;matchMethod($methods);
$this-&gt;matchIps($ips);
$this-&gt;matchScheme($schemes);
foreach ($attributes as $k =&gt; $v) {
$this-&gt;matchAttribute($k, $v);
}
}
public function matchScheme($scheme)
{
$this-&gt;schemes = array_map(&#039;strtolower&#039;, (array) $scheme);
}
public function matchHost($regexp)
{
$this-&gt;host = $regexp;
}
public function matchPath($regexp)
{
$this-&gt;path = $regexp;
}
public function matchIp($ip)
{
$this-&gt;matchIps($ip);
}
public function matchIps($ips)
{
$this-&gt;ips = (array) $ips;
}
public function matchMethod($method)
{
$this-&gt;methods = array_map(&#039;strtoupper&#039;, (array) $method);
}
public function matchAttribute($key, $regexp)
{
$this-&gt;attributes[$key] = $regexp;
}
public function matches(Request $request)
{
if ($this-&gt;schemes &amp;&amp; !in_array($request-&gt;getScheme(), $this-&gt;schemes)) {
return false;
}
if ($this-&gt;methods &amp;&amp; !in_array($request-&gt;getMethod(), $this-&gt;methods)) {
return false;
}
foreach ($this-&gt;attributes as $key =&gt; $pattern) {
if (!preg_match(&#039;{&#039;.$pattern.&#039;}&#039;, $request-&gt;attributes-&gt;get($key))) {
return false;
}
}
if (null !== $this-&gt;path &amp;&amp; !preg_match(&#039;{&#039;.$this-&gt;path.&#039;}&#039;, rawurldecode($request-&gt;getPathInfo()))) {
return false;
}
if (null !== $this-&gt;host &amp;&amp; !preg_match(&#039;{&#039;.$this-&gt;host.&#039;}i&#039;, $request-&gt;getHost())) {
return false;
}
if (IpUtils::checkIp($request-&gt;getClientIp(), $this-&gt;ips)) {
return true;
}
return count($this-&gt;ips) === 0;
}
}
}
namespace
{
class Twig_Environment
{
const VERSION =&#039;1.24.0&#039;;
protected $charset;
protected $loader;
protected $debug;
protected $autoReload;
protected $cache;
protected $lexer;
protected $parser;
protected $compiler;
protected $baseTemplateClass;
protected $extensions;
protected $parsers;
protected $visitors;
protected $filters;
protected $tests;
protected $functions;
protected $globals;
protected $runtimeInitialized = false;
protected $extensionInitialized = false;
protected $loadedTemplates;
protected $strictVariables;
protected $unaryOperators;
protected $binaryOperators;
protected $templateClassPrefix =&#039;__TwigTemplate_&#039;;
protected $functionCallbacks = array();
protected $filterCallbacks = array();
protected $staging;
private $originalCache;
private $bcWriteCacheFile = false;
private $bcGetCacheFilename = false;
private $lastModifiedExtension = 0;
public function __construct(Twig_LoaderInterface $loader = null, $options = array())
{
if (null !== $loader) {
$this-&gt;setLoader($loader);
} else {
@trigger_error(&#039;Not passing a Twig_LoaderInterface as the first constructor argument of Twig_Environment is deprecated since version 1.21.&#039;, E_USER_DEPRECATED);
}
$options = array_merge(array(&#039;debug&#039;=&gt; false,&#039;charset&#039;=&gt;&#039;UTF-8&#039;,&#039;base_template_class&#039;=&gt;&#039;Twig_Template&#039;,&#039;strict_variables&#039;=&gt; false,&#039;autoescape&#039;=&gt;&#039;html&#039;,&#039;cache&#039;=&gt; false,&#039;auto_reload&#039;=&gt; null,&#039;optimizations&#039;=&gt; -1,
), $options);
$this-&gt;debug = (bool) $options[&#039;debug&#039;];
$this-&gt;charset = strtoupper($options[&#039;charset&#039;]);
$this-&gt;baseTemplateClass = $options[&#039;base_template_class&#039;];
$this-&gt;autoReload = null === $options[&#039;auto_reload&#039;] ? $this-&gt;debug : (bool) $options[&#039;auto_reload&#039;];
$this-&gt;strictVariables = (bool) $options[&#039;strict_variables&#039;];
$this-&gt;setCache($options[&#039;cache&#039;]);
$this-&gt;addExtension(new Twig_Extension_Core());
$this-&gt;addExtension(new Twig_Extension_Escaper($options[&#039;autoescape&#039;]));
$this-&gt;addExtension(new Twig_Extension_Optimizer($options[&#039;optimizations&#039;]));
$this-&gt;staging = new Twig_Extension_Staging();
if (is_string($this-&gt;originalCache)) {
$r = new ReflectionMethod($this,&#039;writeCacheFile&#039;);
if ($r-&gt;getDeclaringClass()-&gt;getName() !== __CLASS__) {
@trigger_error(&#039;The Twig_Environment::writeCacheFile method is deprecated since version 1.22 and will be removed in Twig 2.0.&#039;, E_USER_DEPRECATED);
$this-&gt;bcWriteCacheFile = true;
}
$r = new ReflectionMethod($this,&#039;getCacheFilename&#039;);
if ($r-&gt;getDeclaringClass()-&gt;getName() !== __CLASS__) {
@trigger_error(&#039;The Twig_Environment::getCacheFilename method is deprecated since version 1.22 and will be removed in Twig 2.0.&#039;, E_USER_DEPRECATED);
$this-&gt;bcGetCacheFilename = true;
}
}
}
public function getBaseTemplateClass()
{
return $this-&gt;baseTemplateClass;
}
public function setBaseTemplateClass($class)
{
$this-&gt;baseTemplateClass = $class;
}
public function enableDebug()
{
$this-&gt;debug = true;
}
public function disableDebug()
{
$this-&gt;debug = false;
}
public function isDebug()
{
return $this-&gt;debug;
}
public function enableAutoReload()
{
$this-&gt;autoReload = true;
}
public function disableAutoReload()
{
$this-&gt;autoReload = false;
}
public function isAutoReload()
{
return $this-&gt;autoReload;
}
public function enableStrictVariables()
{
$this-&gt;strictVariables = true;
}
public function disableStrictVariables()
{
$this-&gt;strictVariables = false;
}
public function isStrictVariables()
{
return $this-&gt;strictVariables;
}
public function getCache($original = true)
{
return $original ? $this-&gt;originalCache : $this-&gt;cache;
}
public function setCache($cache)
{
if (is_string($cache)) {
$this-&gt;originalCache = $cache;
$this-&gt;cache = new Twig_Cache_Filesystem($cache);
} elseif (false === $cache) {
$this-&gt;originalCache = $cache;
$this-&gt;cache = new Twig_Cache_Null();
} elseif (null === $cache) {
@trigger_error(&#039;Using &quot;null&quot; as the cache strategy is deprecated since version 1.23 and will be removed in Twig 2.0.&#039;, E_USER_DEPRECATED);
$this-&gt;originalCache = false;
$this-&gt;cache = new Twig_Cache_Null();
} elseif ($cache instanceof Twig_CacheInterface) {
$this-&gt;originalCache = $this-&gt;cache = $cache;
} else {
throw new LogicException(sprintf(&#039;Cache can only be a string, false, or a Twig_CacheInterface implementation.&#039;));
}
}
public function getCacheFilename($name)
{
@trigger_error(sprintf(&#039;The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.&#039;, __METHOD__), E_USER_DEPRECATED);
$key = $this-&gt;cache-&gt;generateKey($name, $this-&gt;getTemplateClass($name));
return !$key ? false : $key;
}
public function getTemplateClass($name, $index = null)
{
$key = $this-&gt;getLoader()-&gt;getCacheKey($name);
$key .= json_encode(array_keys($this-&gt;extensions));
$key .= function_exists(&#039;twig_template_get_attributes&#039;);
return $this-&gt;templateClassPrefix.hash(&#039;sha256&#039;, $key).(null === $index ?&#039;&#039;:&#039;_&#039;.$index);
}
public function getTemplateClassPrefix()
{
@trigger_error(sprintf(&#039;The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.&#039;, __METHOD__), E_USER_DEPRECATED);
return $this-&gt;templateClassPrefix;
}
public function render($name, array $context = array())
{
return $this-&gt;loadTemplate($name)-&gt;render($context);
}
public function display($name, array $context = array())
{
$this-&gt;loadTemplate($name)-&gt;display($context);
}
public function loadTemplate($name, $index = null)
{
$cls = $this-&gt;getTemplateClass($name, $index);
if (isset($this-&gt;loadedTemplates[$cls])) {
return $this-&gt;loadedTemplates[$cls];
}
if (!class_exists($cls, false)) {
if ($this-&gt;bcGetCacheFilename) {
$key = $this-&gt;getCacheFilename($name);
} else {
$key = $this-&gt;cache-&gt;generateKey($name, $cls);
}
if (!$this-&gt;isAutoReload() || $this-&gt;isTemplateFresh($name, $this-&gt;cache-&gt;getTimestamp($key))) {
$this-&gt;cache-&gt;load($key);
}
if (!class_exists($cls, false)) {
$content = $this-&gt;compileSource($this-&gt;getLoader()-&gt;getSource($name), $name);
if ($this-&gt;bcWriteCacheFile) {
$this-&gt;writeCacheFile($key, $content);
} else {
$this-&gt;cache-&gt;write($key, $content);
}
eval(&#039;?&gt;&#039;.$content);
}
}
if (!$this-&gt;runtimeInitialized) {
$this-&gt;initRuntime();
}
return $this-&gt;loadedTemplates[$cls] = new $cls($this);
}
public function createTemplate($template)
{
$name = sprintf(&#039;__string_template__%s&#039;, hash(&#039;sha256&#039;, uniqid(mt_rand(), true), false));
$loader = new Twig_Loader_Chain(array(
new Twig_Loader_Array(array($name =&gt; $template)),
$current = $this-&gt;getLoader(),
));
$this-&gt;setLoader($loader);
try {
$template = $this-&gt;loadTemplate($name);
} catch (Exception $e) {
$this-&gt;setLoader($current);
throw $e;
}
$this-&gt;setLoader($current);
return $template;
}
public function isTemplateFresh($name, $time)
{
if (0 === $this-&gt;lastModifiedExtension) {
foreach ($this-&gt;extensions as $extension) {
$r = new ReflectionObject($extension);
if (file_exists($r-&gt;getFileName()) &amp;&amp; ($extensionTime = filemtime($r-&gt;getFileName())) &gt; $this-&gt;lastModifiedExtension) {
$this-&gt;lastModifiedExtension = $extensionTime;
}
}
}
return $this-&gt;lastModifiedExtension &lt;= $time &amp;&amp; $this-&gt;getLoader()-&gt;isFresh($name, $time);
}
public function resolveTemplate($names)
{
if (!is_array($names)) {
$names = array($names);
}
foreach ($names as $name) {
if ($name instanceof Twig_Template) {
return $name;
}
try {
return $this-&gt;loadTemplate($name);
} catch (Twig_Error_Loader $e) {
}
}
if (1 === count($names)) {
throw $e;
}
throw new Twig_Error_Loader(sprintf(&#039;Unable to find one of the following templates: &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, $names)));
}
public function clearTemplateCache()
{
@trigger_error(sprintf(&#039;The %s method is deprecated since version 1.18.3 and will be removed in Twig 2.0.&#039;, __METHOD__), E_USER_DEPRECATED);
$this-&gt;loadedTemplates = array();
}
public function clearCacheFiles()
{
@trigger_error(sprintf(&#039;The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.&#039;, __METHOD__), E_USER_DEPRECATED);
if (is_string($this-&gt;originalCache)) {
foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this-&gt;originalCache), RecursiveIteratorIterator::LEAVES_ONLY) as $file) {
if ($file-&gt;isFile()) {
@unlink($file-&gt;getPathname());
}
}
}
}
public function getLexer()
{
if (null === $this-&gt;lexer) {
$this-&gt;lexer = new Twig_Lexer($this);
}
return $this-&gt;lexer;
}
public function setLexer(Twig_LexerInterface $lexer)
{
$this-&gt;lexer = $lexer;
}
public function tokenize($source, $name = null)
{
return $this-&gt;getLexer()-&gt;tokenize($source, $name);
}
public function getParser()
{
if (null === $this-&gt;parser) {
$this-&gt;parser = new Twig_Parser($this);
}
return $this-&gt;parser;
}
public function setParser(Twig_ParserInterface $parser)
{
$this-&gt;parser = $parser;
}
public function parse(Twig_TokenStream $stream)
{
return $this-&gt;getParser()-&gt;parse($stream);
}
public function getCompiler()
{
if (null === $this-&gt;compiler) {
$this-&gt;compiler = new Twig_Compiler($this);
}
return $this-&gt;compiler;
}
public function setCompiler(Twig_CompilerInterface $compiler)
{
$this-&gt;compiler = $compiler;
}
public function compile(Twig_NodeInterface $node)
{
return $this-&gt;getCompiler()-&gt;compile($node)-&gt;getSource();
}
public function compileSource($source, $name = null)
{
try {
$compiled = $this-&gt;compile($this-&gt;parse($this-&gt;tokenize($source, $name)), $source);
if (isset($source[0])) {
$compiled .=&#039;/* &#039;.str_replace(array(&#039;*/&#039;,&quot;\r\n&quot;,&quot;\r&quot;,&quot;\n&quot;), array(&#039;*//* &#039;,&quot;\n&quot;,&quot;\n&quot;,&quot;*/\n/* &quot;), $source).&quot;*/\n&quot;;
}
return $compiled;
} catch (Twig_Error $e) {
$e-&gt;setTemplateFile($name);
throw $e;
} catch (Exception $e) {
throw new Twig_Error_Syntax(sprintf(&#039;An exception has been thrown during the compilation of a template (&quot;%s&quot;).&#039;, $e-&gt;getMessage()), -1, $name, $e);
}
}
public function setLoader(Twig_LoaderInterface $loader)
{
$this-&gt;loader = $loader;
}
public function getLoader()
{
if (null === $this-&gt;loader) {
throw new LogicException(&#039;You must set a loader first.&#039;);
}
return $this-&gt;loader;
}
public function setCharset($charset)
{
$this-&gt;charset = strtoupper($charset);
}
public function getCharset()
{
return $this-&gt;charset;
}
public function initRuntime()
{
$this-&gt;runtimeInitialized = true;
foreach ($this-&gt;getExtensions() as $name =&gt; $extension) {
if (!$extension instanceof Twig_Extension_InitRuntimeInterface) {
$m = new ReflectionMethod($extension,&#039;initRuntime&#039;);
if (&#039;Twig_Extension&#039;!== $m-&gt;getDeclaringClass()-&gt;getName()) {
@trigger_error(sprintf(&#039;Defining the initRuntime() method in the &quot;%s&quot; extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).&#039;, $name), E_USER_DEPRECATED);
}
}
$extension-&gt;initRuntime($this);
}
}
public function hasExtension($name)
{
return isset($this-&gt;extensions[$name]);
}
public function getExtension($name)
{
if (!isset($this-&gt;extensions[$name])) {
throw new Twig_Error_Runtime(sprintf(&#039;The &quot;%s&quot; extension is not enabled.&#039;, $name));
}
return $this-&gt;extensions[$name];
}
public function addExtension(Twig_ExtensionInterface $extension)
{
$name = $extension-&gt;getName();
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to register extension &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
if (isset($this-&gt;extensions[$name])) {
@trigger_error(sprintf(&#039;The possibility to register the same extension twice (&quot;%s&quot;) is deprecated since version 1.23 and will be removed in Twig 2.0. Use proper PHP inheritance instead.&#039;, $name), E_USER_DEPRECATED);
}
$this-&gt;lastModifiedExtension = 0;
$this-&gt;extensions[$name] = $extension;
}
public function removeExtension($name)
{
@trigger_error(sprintf(&#039;The %s method is deprecated since version 1.12 and will be removed in Twig 2.0.&#039;, __METHOD__), E_USER_DEPRECATED);
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to remove extension &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
unset($this-&gt;extensions[$name]);
}
public function setExtensions(array $extensions)
{
foreach ($extensions as $extension) {
$this-&gt;addExtension($extension);
}
}
public function getExtensions()
{
return $this-&gt;extensions;
}
public function addTokenParser(Twig_TokenParserInterface $parser)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(&#039;Unable to add a token parser as extensions have already been initialized.&#039;);
}
$this-&gt;staging-&gt;addTokenParser($parser);
}
public function getTokenParsers()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;parsers;
}
public function getTags()
{
$tags = array();
foreach ($this-&gt;getTokenParsers()-&gt;getParsers() as $parser) {
if ($parser instanceof Twig_TokenParserInterface) {
$tags[$parser-&gt;getTag()] = $parser;
}
}
return $tags;
}
public function addNodeVisitor(Twig_NodeVisitorInterface $visitor)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(&#039;Unable to add a node visitor as extensions have already been initialized.&#039;);
}
$this-&gt;staging-&gt;addNodeVisitor($visitor);
}
public function getNodeVisitors()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;visitors;
}
public function addFilter($name, $filter = null)
{
if (!$name instanceof Twig_SimpleFilter &amp;&amp; !($filter instanceof Twig_SimpleFilter || $filter instanceof Twig_FilterInterface)) {
throw new LogicException(&#039;A filter must be an instance of Twig_FilterInterface or Twig_SimpleFilter&#039;);
}
if ($name instanceof Twig_SimpleFilter) {
$filter = $name;
$name = $filter-&gt;getName();
} else {
@trigger_error(sprintf(&#039;Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of &quot;Twig_SimpleFilter&quot; instead when defining filter &quot;%s&quot;.&#039;, __METHOD__, $name), E_USER_DEPRECATED);
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add filter &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addFilter($name, $filter);
}
public function getFilter($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;filters[$name])) {
return $this-&gt;filters[$name];
}
foreach ($this-&gt;filters as $pattern =&gt; $filter) {
$pattern = str_replace(&#039;\\*&#039;,&#039;(.*?)&#039;, preg_quote($pattern,&#039;#&#039;), $count);
if ($count) {
if (preg_match(&#039;#^&#039;.$pattern.&#039;$#&#039;, $name, $matches)) {
array_shift($matches);
$filter-&gt;setArguments($matches);
return $filter;
}
}
}
foreach ($this-&gt;filterCallbacks as $callback) {
if (false !== $filter = call_user_func($callback, $name)) {
return $filter;
}
}
return false;
}
public function registerUndefinedFilterCallback($callable)
{
$this-&gt;filterCallbacks[] = $callable;
}
public function getFilters()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;filters;
}
public function addTest($name, $test = null)
{
if (!$name instanceof Twig_SimpleTest &amp;&amp; !($test instanceof Twig_SimpleTest || $test instanceof Twig_TestInterface)) {
throw new LogicException(&#039;A test must be an instance of Twig_TestInterface or Twig_SimpleTest&#039;);
}
if ($name instanceof Twig_SimpleTest) {
$test = $name;
$name = $test-&gt;getName();
} else {
@trigger_error(sprintf(&#039;Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of &quot;Twig_SimpleTest&quot; instead when defining test &quot;%s&quot;.&#039;, __METHOD__, $name), E_USER_DEPRECATED);
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add test &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addTest($name, $test);
}
public function getTests()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;tests;
}
public function getTest($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;tests[$name])) {
return $this-&gt;tests[$name];
}
return false;
}
public function addFunction($name, $function = null)
{
if (!$name instanceof Twig_SimpleFunction &amp;&amp; !($function instanceof Twig_SimpleFunction || $function instanceof Twig_FunctionInterface)) {
throw new LogicException(&#039;A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction&#039;);
}
if ($name instanceof Twig_SimpleFunction) {
$function = $name;
$name = $function-&gt;getName();
} else {
@trigger_error(sprintf(&#039;Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of &quot;Twig_SimpleFunction&quot; instead when defining function &quot;%s&quot;.&#039;, __METHOD__, $name), E_USER_DEPRECATED);
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add function &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addFunction($name, $function);
}
public function getFunction($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;functions[$name])) {
return $this-&gt;functions[$name];
}
foreach ($this-&gt;functions as $pattern =&gt; $function) {
$pattern = str_replace(&#039;\\*&#039;,&#039;(.*?)&#039;, preg_quote($pattern,&#039;#&#039;), $count);
if ($count) {
if (preg_match(&#039;#^&#039;.$pattern.&#039;$#&#039;, $name, $matches)) {
array_shift($matches);
$function-&gt;setArguments($matches);
return $function;
}
}
}
foreach ($this-&gt;functionCallbacks as $callback) {
if (false !== $function = call_user_func($callback, $name)) {
return $function;
}
}
return false;
}
public function registerUndefinedFunctionCallback($callable)
{
$this-&gt;functionCallbacks[] = $callable;
}
public function getFunctions()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;functions;
}
public function addGlobal($name, $value)
{
if ($this-&gt;extensionInitialized || $this-&gt;runtimeInitialized) {
if (null === $this-&gt;globals) {
$this-&gt;globals = $this-&gt;initGlobals();
}
if (!array_key_exists($name, $this-&gt;globals)) {
@trigger_error(sprintf(&#039;Registering global variable &quot;%s&quot; at runtime or when the extensions have already been initialized is deprecated since version 1.21.&#039;, $name), E_USER_DEPRECATED);
}
}
if ($this-&gt;extensionInitialized || $this-&gt;runtimeInitialized) {
$this-&gt;globals[$name] = $value;
} else {
$this-&gt;staging-&gt;addGlobal($name, $value);
}
}
public function getGlobals()
{
if (!$this-&gt;runtimeInitialized &amp;&amp; !$this-&gt;extensionInitialized) {
return $this-&gt;initGlobals();
}
if (null === $this-&gt;globals) {
$this-&gt;globals = $this-&gt;initGlobals();
}
return $this-&gt;globals;
}
public function mergeGlobals(array $context)
{
foreach ($this-&gt;getGlobals() as $key =&gt; $value) {
if (!array_key_exists($key, $context)) {
$context[$key] = $value;
}
}
return $context;
}
public function getUnaryOperators()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;unaryOperators;
}
public function getBinaryOperators()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;binaryOperators;
}
public function computeAlternatives($name, $items)
{
@trigger_error(sprintf(&#039;The %s method is deprecated since version 1.23 and will be removed in Twig 2.0.&#039;, __METHOD__), E_USER_DEPRECATED);
return Twig_Error_Syntax::computeAlternatives($name, $items);
}
protected function initGlobals()
{
$globals = array();
foreach ($this-&gt;extensions as $name =&gt; $extension) {
if (!$extension instanceof Twig_Extension_GlobalsInterface) {
$m = new ReflectionMethod($extension,&#039;getGlobals&#039;);
if (&#039;Twig_Extension&#039;!== $m-&gt;getDeclaringClass()-&gt;getName()) {
@trigger_error(sprintf(&#039;Defining the getGlobals() method in the &quot;%s&quot; extension without explicitly implementing Twig_Extension_GlobalsInterface is deprecated since version 1.23.&#039;, $name), E_USER_DEPRECATED);
}
}
$extGlob = $extension-&gt;getGlobals();
if (!is_array($extGlob)) {
throw new UnexpectedValueException(sprintf(&#039;&quot;%s::getGlobals()&quot; must return an array of globals.&#039;, get_class($extension)));
}
$globals[] = $extGlob;
}
$globals[] = $this-&gt;staging-&gt;getGlobals();
return call_user_func_array(&#039;array_merge&#039;, $globals);
}
protected function initExtensions()
{
if ($this-&gt;extensionInitialized) {
return;
}
$this-&gt;extensionInitialized = true;
$this-&gt;parsers = new Twig_TokenParserBroker(array(), array(), false);
$this-&gt;filters = array();
$this-&gt;functions = array();
$this-&gt;tests = array();
$this-&gt;visitors = array();
$this-&gt;unaryOperators = array();
$this-&gt;binaryOperators = array();
foreach ($this-&gt;extensions as $extension) {
$this-&gt;initExtension($extension);
}
$this-&gt;initExtension($this-&gt;staging);
}
protected function initExtension(Twig_ExtensionInterface $extension)
{
foreach ($extension-&gt;getFilters() as $name =&gt; $filter) {
if ($filter instanceof Twig_SimpleFilter) {
$name = $filter-&gt;getName();
} else {
@trigger_error(sprintf(&#039;Using an instance of &quot;%s&quot; for filter &quot;%s&quot; is deprecated since version 1.21. Use Twig_SimpleFilter instead.&#039;, get_class($filter), $name), E_USER_DEPRECATED);
}
$this-&gt;filters[$name] = $filter;
}
foreach ($extension-&gt;getFunctions() as $name =&gt; $function) {
if ($function instanceof Twig_SimpleFunction) {
$name = $function-&gt;getName();
} else {
@trigger_error(sprintf(&#039;Using an instance of &quot;%s&quot; for function &quot;%s&quot; is deprecated since version 1.21. Use Twig_SimpleFunction instead.&#039;, get_class($function), $name), E_USER_DEPRECATED);
}
$this-&gt;functions[$name] = $function;
}
foreach ($extension-&gt;getTests() as $name =&gt; $test) {
if ($test instanceof Twig_SimpleTest) {
$name = $test-&gt;getName();
} else {
@trigger_error(sprintf(&#039;Using an instance of &quot;%s&quot; for test &quot;%s&quot; is deprecated since version 1.21. Use Twig_SimpleTest instead.&#039;, get_class($test), $name), E_USER_DEPRECATED);
}
$this-&gt;tests[$name] = $test;
}
foreach ($extension-&gt;getTokenParsers() as $parser) {
if ($parser instanceof Twig_TokenParserInterface) {
$this-&gt;parsers-&gt;addTokenParser($parser);
} elseif ($parser instanceof Twig_TokenParserBrokerInterface) {
@trigger_error(&#039;Registering a Twig_TokenParserBrokerInterface instance is deprecated since version 1.21.&#039;, E_USER_DEPRECATED);
$this-&gt;parsers-&gt;addTokenParserBroker($parser);
} else {
throw new LogicException(&#039;getTokenParsers() must return an array of Twig_TokenParserInterface or Twig_TokenParserBrokerInterface instances&#039;);
}
}
foreach ($extension-&gt;getNodeVisitors() as $visitor) {
$this-&gt;visitors[] = $visitor;
}
if ($operators = $extension-&gt;getOperators()) {
if (2 !== count($operators)) {
throw new InvalidArgumentException(sprintf(&#039;&quot;%s::getOperators()&quot; does not return a valid operators array.&#039;, get_class($extension)));
}
$this-&gt;unaryOperators = array_merge($this-&gt;unaryOperators, $operators[0]);
$this-&gt;binaryOperators = array_merge($this-&gt;binaryOperators, $operators[1]);
}
}
protected function writeCacheFile($file, $content)
{
$this-&gt;cache-&gt;write($file, $content);
}
}
}
namespace
{
interface Twig_ExtensionInterface
{
public function initRuntime(Twig_Environment $environment);
public function getTokenParsers();
public function getNodeVisitors();
public function getFilters();
public function getTests();
public function getFunctions();
public function getOperators();
public function getGlobals();
public function getName();
}
}
namespace
{
abstract class Twig_Extension implements Twig_ExtensionInterface
{
public function initRuntime(Twig_Environment $environment)
{
}
public function getTokenParsers()
{
return array();
}
public function getNodeVisitors()
{
return array();
}
public function getFilters()
{
return array();
}
public function getTests()
{
return array();
}
public function getFunctions()
{
return array();
}
public function getOperators()
{
return array();
}
public function getGlobals()
{
return array();
}
}
}
namespace
{
if (!defined(&#039;ENT_SUBSTITUTE&#039;)) {
define(&#039;ENT_SUBSTITUTE&#039;, 0);
}
class Twig_Extension_Core extends Twig_Extension
{
protected $dateFormats = array(&#039;F j, Y H:i&#039;,&#039;%d days&#039;);
protected $numberFormat = array(0,&#039;.&#039;,&#039;,&#039;);
protected $timezone = null;
protected $escapers = array();
public function setEscaper($strategy, $callable)
{
$this-&gt;escapers[$strategy] = $callable;
}
public function getEscapers()
{
return $this-&gt;escapers;
}
public function setDateFormat($format = null, $dateIntervalFormat = null)
{
if (null !== $format) {
$this-&gt;dateFormats[0] = $format;
}
if (null !== $dateIntervalFormat) {
$this-&gt;dateFormats[1] = $dateIntervalFormat;
}
}
public function getDateFormat()
{
return $this-&gt;dateFormats;
}
public function setTimezone($timezone)
{
$this-&gt;timezone = $timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone);
}
public function getTimezone()
{
if (null === $this-&gt;timezone) {
$this-&gt;timezone = new DateTimeZone(date_default_timezone_get());
}
return $this-&gt;timezone;
}
public function setNumberFormat($decimal, $decimalPoint, $thousandSep)
{
$this-&gt;numberFormat = array($decimal, $decimalPoint, $thousandSep);
}
public function getNumberFormat()
{
return $this-&gt;numberFormat;
}
public function getTokenParsers()
{
return array(
new Twig_TokenParser_For(),
new Twig_TokenParser_If(),
new Twig_TokenParser_Extends(),
new Twig_TokenParser_Include(),
new Twig_TokenParser_Block(),
new Twig_TokenParser_Use(),
new Twig_TokenParser_Filter(),
new Twig_TokenParser_Macro(),
new Twig_TokenParser_Import(),
new Twig_TokenParser_From(),
new Twig_TokenParser_Set(),
new Twig_TokenParser_Spaceless(),
new Twig_TokenParser_Flush(),
new Twig_TokenParser_Do(),
new Twig_TokenParser_Embed(),
);
}
public function getFilters()
{
$filters = array(
new Twig_SimpleFilter(&#039;date&#039;,&#039;twig_date_format_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;date_modify&#039;,&#039;twig_date_modify_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;format&#039;,&#039;sprintf&#039;),
new Twig_SimpleFilter(&#039;replace&#039;,&#039;twig_replace_filter&#039;),
new Twig_SimpleFilter(&#039;number_format&#039;,&#039;twig_number_format_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;abs&#039;,&#039;abs&#039;),
new Twig_SimpleFilter(&#039;round&#039;,&#039;twig_round&#039;),
new Twig_SimpleFilter(&#039;url_encode&#039;,&#039;twig_urlencode_filter&#039;),
new Twig_SimpleFilter(&#039;json_encode&#039;,&#039;twig_jsonencode_filter&#039;),
new Twig_SimpleFilter(&#039;convert_encoding&#039;,&#039;twig_convert_encoding&#039;),
new Twig_SimpleFilter(&#039;title&#039;,&#039;twig_title_string_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;capitalize&#039;,&#039;twig_capitalize_string_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;upper&#039;,&#039;strtoupper&#039;),
new Twig_SimpleFilter(&#039;lower&#039;,&#039;strtolower&#039;),
new Twig_SimpleFilter(&#039;striptags&#039;,&#039;strip_tags&#039;),
new Twig_SimpleFilter(&#039;trim&#039;,&#039;trim&#039;),
new Twig_SimpleFilter(&#039;nl2br&#039;,&#039;nl2br&#039;, array(&#039;pre_escape&#039;=&gt;&#039;html&#039;,&#039;is_safe&#039;=&gt; array(&#039;html&#039;))),
new Twig_SimpleFilter(&#039;join&#039;,&#039;twig_join_filter&#039;),
new Twig_SimpleFilter(&#039;split&#039;,&#039;twig_split_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;sort&#039;,&#039;twig_sort_filter&#039;),
new Twig_SimpleFilter(&#039;merge&#039;,&#039;twig_array_merge&#039;),
new Twig_SimpleFilter(&#039;batch&#039;,&#039;twig_array_batch&#039;),
new Twig_SimpleFilter(&#039;reverse&#039;,&#039;twig_reverse_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;length&#039;,&#039;twig_length_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;slice&#039;,&#039;twig_slice&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;first&#039;,&#039;twig_first&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;last&#039;,&#039;twig_last&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;default&#039;,&#039;_twig_default_filter&#039;, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Filter_Default&#039;)),
new Twig_SimpleFilter(&#039;keys&#039;,&#039;twig_get_array_keys_filter&#039;),
new Twig_SimpleFilter(&#039;escape&#039;,&#039;twig_escape_filter&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;is_safe_callback&#039;=&gt;&#039;twig_escape_filter_is_safe&#039;)),
new Twig_SimpleFilter(&#039;e&#039;,&#039;twig_escape_filter&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;is_safe_callback&#039;=&gt;&#039;twig_escape_filter_is_safe&#039;)),
);
if (function_exists(&#039;mb_get_info&#039;)) {
$filters[] = new Twig_SimpleFilter(&#039;upper&#039;,&#039;twig_upper_filter&#039;, array(&#039;needs_environment&#039;=&gt; true));
$filters[] = new Twig_SimpleFilter(&#039;lower&#039;,&#039;twig_lower_filter&#039;, array(&#039;needs_environment&#039;=&gt; true));
}
return $filters;
}
public function getFunctions()
{
return array(
new Twig_SimpleFunction(&#039;max&#039;,&#039;max&#039;),
new Twig_SimpleFunction(&#039;min&#039;,&#039;min&#039;),
new Twig_SimpleFunction(&#039;range&#039;,&#039;range&#039;),
new Twig_SimpleFunction(&#039;constant&#039;,&#039;twig_constant&#039;),
new Twig_SimpleFunction(&#039;cycle&#039;,&#039;twig_cycle&#039;),
new Twig_SimpleFunction(&#039;random&#039;,&#039;twig_random&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFunction(&#039;date&#039;,&#039;twig_date_converter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFunction(&#039;include&#039;,&#039;twig_include&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;needs_context&#039;=&gt; true,&#039;is_safe&#039;=&gt; array(&#039;all&#039;))),
new Twig_SimpleFunction(&#039;source&#039;,&#039;twig_source&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;is_safe&#039;=&gt; array(&#039;all&#039;))),
);
}
public function getTests()
{
return array(
new Twig_SimpleTest(&#039;even&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Even&#039;)),
new Twig_SimpleTest(&#039;odd&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Odd&#039;)),
new Twig_SimpleTest(&#039;defined&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Defined&#039;)),
new Twig_SimpleTest(&#039;sameas&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Sameas&#039;,&#039;deprecated&#039;=&gt;&#039;1.21&#039;,&#039;alternative&#039;=&gt;&#039;same as&#039;)),
new Twig_SimpleTest(&#039;same as&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Sameas&#039;)),
new Twig_SimpleTest(&#039;none&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Null&#039;)),
new Twig_SimpleTest(&#039;null&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Null&#039;)),
new Twig_SimpleTest(&#039;divisibleby&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Divisibleby&#039;,&#039;deprecated&#039;=&gt;&#039;1.21&#039;,&#039;alternative&#039;=&gt;&#039;divisible by&#039;)),
new Twig_SimpleTest(&#039;divisible by&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Divisibleby&#039;)),
new Twig_SimpleTest(&#039;constant&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Constant&#039;)),
new Twig_SimpleTest(&#039;empty&#039;,&#039;twig_test_empty&#039;),
new Twig_SimpleTest(&#039;iterable&#039;,&#039;twig_test_iterable&#039;),
);
}
public function getOperators()
{
return array(
array(&#039;not&#039;=&gt; array(&#039;precedence&#039;=&gt; 50,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Not&#039;),&#039;-&#039;=&gt; array(&#039;precedence&#039;=&gt; 500,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Neg&#039;),&#039;+&#039;=&gt; array(&#039;precedence&#039;=&gt; 500,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Pos&#039;),
),
array(&#039;or&#039;=&gt; array(&#039;precedence&#039;=&gt; 10,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Or&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;and&#039;=&gt; array(&#039;precedence&#039;=&gt; 15,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_And&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-or&#039;=&gt; array(&#039;precedence&#039;=&gt; 16,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseOr&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-xor&#039;=&gt; array(&#039;precedence&#039;=&gt; 17,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseXor&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-and&#039;=&gt; array(&#039;precedence&#039;=&gt; 18,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseAnd&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;==&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Equal&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;!=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_NotEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&lt;&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Less&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&gt;&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Greater&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&gt;=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_GreaterEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&lt;=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_LessEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;not in&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_NotIn&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;in&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_In&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;matches&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Matches&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;starts with&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_StartsWith&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;ends with&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_EndsWith&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;..&#039;=&gt; array(&#039;precedence&#039;=&gt; 25,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Range&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;+&#039;=&gt; array(&#039;precedence&#039;=&gt; 30,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Add&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;-&#039;=&gt; array(&#039;precedence&#039;=&gt; 30,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Sub&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;~&#039;=&gt; array(&#039;precedence&#039;=&gt; 40,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Concat&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;*&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Mul&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;/&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Div&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;//&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_FloorDiv&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;%&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Mod&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;is&#039;=&gt; array(&#039;precedence&#039;=&gt; 100,&#039;callable&#039;=&gt; array($this,&#039;parseTestExpression&#039;),&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;is not&#039;=&gt; array(&#039;precedence&#039;=&gt; 100,&#039;callable&#039;=&gt; array($this,&#039;parseNotTestExpression&#039;),&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;**&#039;=&gt; array(&#039;precedence&#039;=&gt; 200,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Power&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_RIGHT),&#039;??&#039;=&gt; array(&#039;precedence&#039;=&gt; 300,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_NullCoalesce&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_RIGHT),
),
);
}
public function parseNotTestExpression(Twig_Parser $parser, Twig_NodeInterface $node)
{
return new Twig_Node_Expression_Unary_Not($this-&gt;parseTestExpression($parser, $node), $parser-&gt;getCurrentToken()-&gt;getLine());
}
public function parseTestExpression(Twig_Parser $parser, Twig_NodeInterface $node)
{
$stream = $parser-&gt;getStream();
list($name, $test) = $this-&gt;getTest($parser, $node-&gt;getLine());
if ($test instanceof Twig_SimpleTest &amp;&amp; $test-&gt;isDeprecated()) {
$message = sprintf(&#039;Twig Test &quot;%s&quot; is deprecated&#039;, $name);
if (!is_bool($test-&gt;getDeprecatedVersion())) {
$message .= sprintf(&#039; since version %s&#039;, $test-&gt;getDeprecatedVersion());
}
if ($test-&gt;getAlternative()) {
$message .= sprintf(&#039;. Use &quot;%s&quot; instead&#039;, $test-&gt;getAlternative());
}
$message .= sprintf(&#039; in %s at line %d.&#039;, $stream-&gt;getFilename(), $stream-&gt;getCurrent()-&gt;getLine());
@trigger_error($message, E_USER_DEPRECATED);
}
$class = $this-&gt;getTestNodeClass($parser, $test);
$arguments = null;
if ($stream-&gt;test(Twig_Token::PUNCTUATION_TYPE,&#039;(&#039;)) {
$arguments = $parser-&gt;getExpressionParser()-&gt;parseArguments(true);
}
return new $class($node, $name, $arguments, $parser-&gt;getCurrentToken()-&gt;getLine());
}
protected function getTest(Twig_Parser $parser, $line)
{
$stream = $parser-&gt;getStream();
$name = $stream-&gt;expect(Twig_Token::NAME_TYPE)-&gt;getValue();
$env = $parser-&gt;getEnvironment();
if ($test = $env-&gt;getTest($name)) {
return array($name, $test);
}
if ($stream-&gt;test(Twig_Token::NAME_TYPE)) {
$name = $name.&#039; &#039;.$parser-&gt;getCurrentToken()-&gt;getValue();
if ($test = $env-&gt;getTest($name)) {
$parser-&gt;getStream()-&gt;next();
return array($name, $test);
}
}
$e = new Twig_Error_Syntax(sprintf(&#039;Unknown &quot;%s&quot; test.&#039;, $name), $line, $parser-&gt;getFilename());
$e-&gt;addSuggestions($name, array_keys($env-&gt;getTests()));
throw $e;
}
protected function getTestNodeClass(Twig_Parser $parser, $test)
{
if ($test instanceof Twig_SimpleTest) {
return $test-&gt;getNodeClass();
}
return $test instanceof Twig_Test_Node ? $test-&gt;getClass() :&#039;Twig_Node_Expression_Test&#039;;
}
public function getName()
{
return&#039;core&#039;;
}
}
function twig_cycle($values, $position)
{
if (!is_array($values) &amp;&amp; !$values instanceof ArrayAccess) {
return $values;
}
return $values[$position % count($values)];
}
function twig_random(Twig_Environment $env, $values = null)
{
if (null === $values) {
return mt_rand();
}
if (is_int($values) || is_float($values)) {
return $values &lt; 0 ? mt_rand($values, 0) : mt_rand(0, $values);
}
if ($values instanceof Traversable) {
$values = iterator_to_array($values);
} elseif (is_string($values)) {
if (&#039;&#039;=== $values) {
return&#039;&#039;;
}
if (null !== $charset = $env-&gt;getCharset()) {
if (&#039;UTF-8&#039;!== $charset) {
$values = twig_convert_encoding($values,&#039;UTF-8&#039;, $charset);
}
$values = preg_split(&#039;/(?&lt;!^)(?!$)/u&#039;, $values);
if (&#039;UTF-8&#039;!== $charset) {
foreach ($values as $i =&gt; $value) {
$values[$i] = twig_convert_encoding($value, $charset,&#039;UTF-8&#039;);
}
}
} else {
return $values[mt_rand(0, strlen($values) - 1)];
}
}
if (!is_array($values)) {
return $values;
}
if (0 === count($values)) {
throw new Twig_Error_Runtime(&#039;The random function cannot pick from an empty array.&#039;);
}
return $values[array_rand($values, 1)];
}
function twig_date_format_filter(Twig_Environment $env, $date, $format = null, $timezone = null)
{
if (null === $format) {
$formats = $env-&gt;getExtension(&#039;core&#039;)-&gt;getDateFormat();
$format = $date instanceof DateInterval ? $formats[1] : $formats[0];
}
if ($date instanceof DateInterval) {
return $date-&gt;format($format);
}
return twig_date_converter($env, $date, $timezone)-&gt;format($format);
}
function twig_date_modify_filter(Twig_Environment $env, $date, $modifier)
{
$date = twig_date_converter($env, $date, false);
$resultDate = $date-&gt;modify($modifier);
return null === $resultDate ? $date : $resultDate;
}
function twig_date_converter(Twig_Environment $env, $date = null, $timezone = null)
{
if (false !== $timezone) {
if (null === $timezone) {
$timezone = $env-&gt;getExtension(&#039;core&#039;)-&gt;getTimezone();
} elseif (!$timezone instanceof DateTimeZone) {
$timezone = new DateTimeZone($timezone);
}
}
if ($date instanceof DateTimeImmutable) {
return false !== $timezone ? $date-&gt;setTimezone($timezone) : $date;
}
if ($date instanceof DateTime || $date instanceof DateTimeInterface) {
$date = clone $date;
if (false !== $timezone) {
$date-&gt;setTimezone($timezone);
}
return $date;
}
if (null === $date ||&#039;now&#039;=== $date) {
return new DateTime($date, false !== $timezone ? $timezone : $env-&gt;getExtension(&#039;core&#039;)-&gt;getTimezone());
}
$asString = (string) $date;
if (ctype_digit($asString) || (!empty($asString) &amp;&amp;&#039;-&#039;=== $asString[0] &amp;&amp; ctype_digit(substr($asString, 1)))) {
$date = new DateTime(&#039;@&#039;.$date);
} else {
$date = new DateTime($date, $env-&gt;getExtension(&#039;core&#039;)-&gt;getTimezone());
}
if (false !== $timezone) {
$date-&gt;setTimezone($timezone);
}
return $date;
}
function twig_replace_filter($str, $from, $to = null)
{
if ($from instanceof Traversable) {
$from = iterator_to_array($from);
} elseif (is_string($from) &amp;&amp; is_string($to)) {
@trigger_error(&#039;Using &quot;replace&quot; with character by character replacement is deprecated since version 1.22 and will be removed in Twig 2.0&#039;, E_USER_DEPRECATED);
return strtr($str, $from, $to);
} elseif (!is_array($from)) {
throw new Twig_Error_Runtime(sprintf(&#039;The &quot;replace&quot; filter expects an array or &quot;Traversable&quot; as replace values, got &quot;%s&quot;.&#039;,is_object($from) ? get_class($from) : gettype($from)));
}
return strtr($str, $from);
}
function twig_round($value, $precision = 0, $method =&#039;common&#039;)
{
if (&#039;common&#039;== $method) {
return round($value, $precision);
}
if (&#039;ceil&#039;!= $method &amp;&amp;&#039;floor&#039;!= $method) {
throw new Twig_Error_Runtime(&#039;The round filter only supports the &quot;common&quot;, &quot;ceil&quot;, and &quot;floor&quot; methods.&#039;);
}
return $method($value * pow(10, $precision)) / pow(10, $precision);
}
function twig_number_format_filter(Twig_Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null)
{
$defaults = $env-&gt;getExtension(&#039;core&#039;)-&gt;getNumberFormat();
if (null === $decimal) {
$decimal = $defaults[0];
}
if (null === $decimalPoint) {
$decimalPoint = $defaults[1];
}
if (null === $thousandSep) {
$thousandSep = $defaults[2];
}
return number_format((float) $number, $decimal, $decimalPoint, $thousandSep);
}
function twig_urlencode_filter($url)
{
if (is_array($url)) {
if (defined(&#039;PHP_QUERY_RFC3986&#039;)) {
return http_build_query($url,&#039;&#039;,&#039;&amp;&#039;, PHP_QUERY_RFC3986);
}
return http_build_query($url,&#039;&#039;,&#039;&amp;&#039;);
}
return rawurlencode($url);
}
if (PHP_VERSION_ID &lt; 50300) {
function twig_jsonencode_filter($value, $options = 0)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
} elseif (is_array($value)) {
array_walk_recursive($value,&#039;_twig_markup2string&#039;);
}
return json_encode($value);
}
} else {
function twig_jsonencode_filter($value, $options = 0)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
} elseif (is_array($value)) {
array_walk_recursive($value,&#039;_twig_markup2string&#039;);
}
return json_encode($value, $options);
}
}
function _twig_markup2string(&amp;$value)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
}
}
function twig_array_merge($arr1, $arr2)
{
if ($arr1 instanceof Traversable) {
$arr1 = iterator_to_array($arr1);
} elseif (!is_array($arr1)) {
throw new Twig_Error_Runtime(sprintf(&#039;The merge filter only works with arrays or &quot;Traversable&quot;, got &quot;%s&quot; as first argument.&#039;, gettype($arr1)));
}
if ($arr2 instanceof Traversable) {
$arr2 = iterator_to_array($arr2);
} elseif (!is_array($arr2)) {
throw new Twig_Error_Runtime(sprintf(&#039;The merge filter only works with arrays or &quot;Traversable&quot;, got &quot;%s&quot; as second argument.&#039;, gettype($arr2)));
}
return array_merge($arr1, $arr2);
}
function twig_slice(Twig_Environment $env, $item, $start, $length = null, $preserveKeys = false)
{
if ($item instanceof Traversable) {
if ($item instanceof IteratorAggregate) {
$item = $item-&gt;getIterator();
}
if ($start &gt;= 0 &amp;&amp; $length &gt;= 0 &amp;&amp; $item instanceof Iterator) {
try {
return iterator_to_array(new LimitIterator($item, $start, $length === null ? -1 : $length), $preserveKeys);
} catch (OutOfBoundsException $exception) {
return array();
}
}
$item = iterator_to_array($item, $preserveKeys);
}
if (is_array($item)) {
return array_slice($item, $start, $length, $preserveKeys);
}
$item = (string) $item;
if (function_exists(&#039;mb_get_info&#039;) &amp;&amp; null !== $charset = $env-&gt;getCharset()) {
return (string) mb_substr($item, $start, null === $length ? mb_strlen($item, $charset) - $start : $length, $charset);
}
return (string) (null === $length ? substr($item, $start) : substr($item, $start, $length));
}
function twig_first(Twig_Environment $env, $item)
{
$elements = twig_slice($env, $item, 0, 1, false);
return is_string($elements) ? $elements : current($elements);
}
function twig_last(Twig_Environment $env, $item)
{
$elements = twig_slice($env, $item, -1, 1, false);
return is_string($elements) ? $elements : current($elements);
}
function twig_join_filter($value, $glue =&#039;&#039;)
{
if ($value instanceof Traversable) {
$value = iterator_to_array($value, false);
}
return implode($glue, (array) $value);
}
function twig_split_filter(Twig_Environment $env, $value, $delimiter, $limit = null)
{
if (!empty($delimiter)) {
return null === $limit ? explode($delimiter, $value) : explode($delimiter, $value, $limit);
}
if (!function_exists(&#039;mb_get_info&#039;) || null === $charset = $env-&gt;getCharset()) {
return str_split($value, null === $limit ? 1 : $limit);
}
if ($limit &lt;= 1) {
return preg_split(&#039;/(?&lt;!^)(?!$)/u&#039;, $value);
}
$length = mb_strlen($value, $charset);
if ($length &lt; $limit) {
return array($value);
}
$r = array();
for ($i = 0; $i &lt; $length; $i += $limit) {
$r[] = mb_substr($value, $i, $limit, $charset);
}
return $r;
}
function _twig_default_filter($value, $default =&#039;&#039;)
{
if (twig_test_empty($value)) {
return $default;
}
return $value;
}
function twig_get_array_keys_filter($array)
{
if ($array instanceof Traversable) {
return array_keys(iterator_to_array($array));
}
if (!is_array($array)) {
return array();
}
return array_keys($array);
}
function twig_reverse_filter(Twig_Environment $env, $item, $preserveKeys = false)
{
if ($item instanceof Traversable) {
return array_reverse(iterator_to_array($item), $preserveKeys);
}
if (is_array($item)) {
return array_reverse($item, $preserveKeys);
}
if (null !== $charset = $env-&gt;getCharset()) {
$string = (string) $item;
if (&#039;UTF-8&#039;!== $charset) {
$item = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
preg_match_all(&#039;/./us&#039;, $item, $matches);
$string = implode(&#039;&#039;, array_reverse($matches[0]));
if (&#039;UTF-8&#039;!== $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
}
return strrev((string) $item);
}
function twig_sort_filter($array)
{
if ($array instanceof Traversable) {
$array = iterator_to_array($array);
} elseif (!is_array($array)) {
throw new Twig_Error_Runtime(sprintf(&#039;The sort filter only works with arrays or &quot;Traversable&quot;, got &quot;%s&quot;.&#039;, gettype($array)));
}
asort($array);
return $array;
}
function twig_in_filter($value, $compare)
{
if (is_array($compare)) {
return in_array($value, $compare, is_object($value) || is_resource($value));
} elseif (is_string($compare) &amp;&amp; (is_string($value) || is_int($value) || is_float($value))) {
return&#039;&#039;=== $value || false !== strpos($compare, (string) $value);
} elseif ($compare instanceof Traversable) {
return in_array($value, iterator_to_array($compare, false), is_object($value) || is_resource($value));
}
return false;
}
function twig_escape_filter(Twig_Environment $env, $string, $strategy =&#039;html&#039;, $charset = null, $autoescape = false)
{
if ($autoescape &amp;&amp; $string instanceof Twig_Markup) {
return $string;
}
if (!is_string($string)) {
if (is_object($string) &amp;&amp; method_exists($string,&#039;__toString&#039;)) {
$string = (string) $string;
} elseif (in_array($strategy, array(&#039;html&#039;,&#039;js&#039;,&#039;css&#039;,&#039;html_attr&#039;,&#039;url&#039;))) {
return $string;
}
}
if (null === $charset) {
$charset = $env-&gt;getCharset();
}
switch ($strategy) {
case&#039;html&#039;:
static $htmlspecialcharsCharsets;
if (null === $htmlspecialcharsCharsets) {
if (defined(&#039;HHVM_VERSION&#039;)) {
$htmlspecialcharsCharsets = array(&#039;utf-8&#039;=&gt; true,&#039;UTF-8&#039;=&gt; true);
} else {
$htmlspecialcharsCharsets = array(&#039;ISO-8859-1&#039;=&gt; true,&#039;ISO8859-1&#039;=&gt; true,&#039;ISO-8859-15&#039;=&gt; true,&#039;ISO8859-15&#039;=&gt; true,&#039;utf-8&#039;=&gt; true,&#039;UTF-8&#039;=&gt; true,&#039;CP866&#039;=&gt; true,&#039;IBM866&#039;=&gt; true,&#039;866&#039;=&gt; true,&#039;CP1251&#039;=&gt; true,&#039;WINDOWS-1251&#039;=&gt; true,&#039;WIN-1251&#039;=&gt; true,&#039;1251&#039;=&gt; true,&#039;CP1252&#039;=&gt; true,&#039;WINDOWS-1252&#039;=&gt; true,&#039;1252&#039;=&gt; true,&#039;KOI8-R&#039;=&gt; true,&#039;KOI8-RU&#039;=&gt; true,&#039;KOI8R&#039;=&gt; true,&#039;BIG5&#039;=&gt; true,&#039;950&#039;=&gt; true,&#039;GB2312&#039;=&gt; true,&#039;936&#039;=&gt; true,&#039;BIG5-HKSCS&#039;=&gt; true,&#039;SHIFT_JIS&#039;=&gt; true,&#039;SJIS&#039;=&gt; true,&#039;932&#039;=&gt; true,&#039;EUC-JP&#039;=&gt; true,&#039;EUCJP&#039;=&gt; true,&#039;ISO8859-5&#039;=&gt; true,&#039;ISO-8859-5&#039;=&gt; true,&#039;MACROMAN&#039;=&gt; true,
);
}
}
if (isset($htmlspecialcharsCharsets[$charset])) {
return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
}
if (isset($htmlspecialcharsCharsets[strtoupper($charset)])) {
$htmlspecialcharsCharsets[$charset] = true;
return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
}
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
$string = htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE,&#039;UTF-8&#039;);
return twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
case&#039;js&#039;:
if (&#039;UTF-8&#039;!== $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9,\._]#Su&#039;,&#039;_twig_escape_js_callback&#039;, $string);
if (&#039;UTF-8&#039;!== $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;css&#039;:
if (&#039;UTF-8&#039;!== $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9]#Su&#039;,&#039;_twig_escape_css_callback&#039;, $string);
if (&#039;UTF-8&#039;!== $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;html_attr&#039;:
if (&#039;UTF-8&#039;!== $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9,\.\-_]#Su&#039;,&#039;_twig_escape_html_attr_callback&#039;, $string);
if (&#039;UTF-8&#039;!== $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;url&#039;:
if (PHP_VERSION_ID &lt; 50300) {
return str_replace(&#039;%7E&#039;,&#039;~&#039;, rawurlencode($string));
}
return rawurlencode($string);
default:
static $escapers;
if (null === $escapers) {
$escapers = $env-&gt;getExtension(&#039;core&#039;)-&gt;getEscapers();
}
if (isset($escapers[$strategy])) {
return call_user_func($escapers[$strategy], $env, $string, $charset);
}
$validStrategies = implode(&#039;, &#039;, array_merge(array(&#039;html&#039;,&#039;js&#039;,&#039;url&#039;,&#039;css&#039;,&#039;html_attr&#039;), array_keys($escapers)));
throw new Twig_Error_Runtime(sprintf(&#039;Invalid escaping strategy &quot;%s&quot; (valid ones: %s).&#039;, $strategy, $validStrategies));
}
}
function twig_escape_filter_is_safe(Twig_Node $filterArgs)
{
foreach ($filterArgs as $arg) {
if ($arg instanceof Twig_Node_Expression_Constant) {
return array($arg-&gt;getAttribute(&#039;value&#039;));
}
return array();
}
return array(&#039;html&#039;);
}
if (function_exists(&#039;mb_convert_encoding&#039;)) {
function twig_convert_encoding($string, $to, $from)
{
return mb_convert_encoding($string, $to, $from);
}
} elseif (function_exists(&#039;iconv&#039;)) {
function twig_convert_encoding($string, $to, $from)
{
return iconv($from, $to, $string);
}
} else {
function twig_convert_encoding($string, $to, $from)
{
throw new Twig_Error_Runtime(&#039;No suitable convert encoding function (use UTF-8 as your encoding or install the iconv or mbstring extension).&#039;);
}
}
function _twig_escape_js_callback($matches)
{
$char = $matches[0];
if (!isset($char[1])) {
return&#039;\\x&#039;.strtoupper(substr(&#039;00&#039;.bin2hex($char), -2));
}
$char = twig_convert_encoding($char,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
return&#039;\\u&#039;.strtoupper(substr(&#039;0000&#039;.bin2hex($char), -4));
}
function _twig_escape_css_callback($matches)
{
$char = $matches[0];
if (!isset($char[1])) {
$hex = ltrim(strtoupper(bin2hex($char)),&#039;0&#039;);
if (0 === strlen($hex)) {
$hex =&#039;0&#039;;
}
return&#039;\\&#039;.$hex.&#039; &#039;;
}
$char = twig_convert_encoding($char,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
return&#039;\\&#039;.ltrim(strtoupper(bin2hex($char)),&#039;0&#039;).&#039; &#039;;
}
function _twig_escape_html_attr_callback($matches)
{
static $entityMap = array(
34 =&gt;&#039;quot&#039;,
38 =&gt;&#039;amp&#039;,
60 =&gt;&#039;lt&#039;,
62 =&gt;&#039;gt&#039;,
);
$chr = $matches[0];
$ord = ord($chr);
if (($ord &lt;= 0x1f &amp;&amp; $chr !=&quot;\t&quot;&amp;&amp; $chr !=&quot;\n&quot;&amp;&amp; $chr !=&quot;\r&quot;) || ($ord &gt;= 0x7f &amp;&amp; $ord &lt;= 0x9f)) {
return&#039;&amp;#xFFFD;&#039;;
}
if (strlen($chr) == 1) {
$hex = strtoupper(substr(&#039;00&#039;.bin2hex($chr), -2));
} else {
$chr = twig_convert_encoding($chr,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
$hex = strtoupper(substr(&#039;0000&#039;.bin2hex($chr), -4));
}
$int = hexdec($hex);
if (array_key_exists($int, $entityMap)) {
return sprintf(&#039;&amp;%s;&#039;, $entityMap[$int]);
}
return sprintf(&#039;&amp;#x%s;&#039;, $hex);
}
if (function_exists(&#039;mb_get_info&#039;)) {
function twig_length_filter(Twig_Environment $env, $thing)
{
return is_scalar($thing) ? mb_strlen($thing, $env-&gt;getCharset()) : count($thing);
}
function twig_upper_filter(Twig_Environment $env, $string)
{
if (null !== $charset = $env-&gt;getCharset()) {
return mb_strtoupper($string, $charset);
}
return strtoupper($string);
}
function twig_lower_filter(Twig_Environment $env, $string)
{
if (null !== $charset = $env-&gt;getCharset()) {
return mb_strtolower($string, $charset);
}
return strtolower($string);
}
function twig_title_string_filter(Twig_Environment $env, $string)
{
if (null !== $charset = $env-&gt;getCharset()) {
return mb_convert_case($string, MB_CASE_TITLE, $charset);
}
return ucwords(strtolower($string));
}
function twig_capitalize_string_filter(Twig_Environment $env, $string)
{
if (null !== $charset = $env-&gt;getCharset()) {
return mb_strtoupper(mb_substr($string, 0, 1, $charset), $charset).mb_strtolower(mb_substr($string, 1, mb_strlen($string, $charset), $charset), $charset);
}
return ucfirst(strtolower($string));
}
}
else {
function twig_length_filter(Twig_Environment $env, $thing)
{
return is_scalar($thing) ? strlen($thing) : count($thing);
}
function twig_title_string_filter(Twig_Environment $env, $string)
{
return ucwords(strtolower($string));
}
function twig_capitalize_string_filter(Twig_Environment $env, $string)
{
return ucfirst(strtolower($string));
}
}
function twig_ensure_traversable($seq)
{
if ($seq instanceof Traversable || is_array($seq)) {
return $seq;
}
return array();
}
function twig_test_empty($value)
{
if ($value instanceof Countable) {
return 0 == count($value);
}
return&#039;&#039;=== $value || false === $value || null === $value || array() === $value;
}
function twig_test_iterable($value)
{
return $value instanceof Traversable || is_array($value);
}
function twig_include(Twig_Environment $env, $context, $template, $variables = array(), $withContext = true, $ignoreMissing = false, $sandboxed = false)
{
$alreadySandboxed = false;
$sandbox = null;
if ($withContext) {
$variables = array_merge($context, $variables);
}
if ($isSandboxed = $sandboxed &amp;&amp; $env-&gt;hasExtension(&#039;sandbox&#039;)) {
$sandbox = $env-&gt;getExtension(&#039;sandbox&#039;);
if (!$alreadySandboxed = $sandbox-&gt;isSandboxed()) {
$sandbox-&gt;enableSandbox();
}
}
$result = null;
try {
$result = $env-&gt;resolveTemplate($template)-&gt;render($variables);
} catch (Twig_Error_Loader $e) {
if (!$ignoreMissing) {
if ($isSandboxed &amp;&amp; !$alreadySandboxed) {
$sandbox-&gt;disableSandbox();
}
throw $e;
}
}
if ($isSandboxed &amp;&amp; !$alreadySandboxed) {
$sandbox-&gt;disableSandbox();
}
return $result;
}
function twig_source(Twig_Environment $env, $name, $ignoreMissing = false)
{
try {
return $env-&gt;getLoader()-&gt;getSource($name);
} catch (Twig_Error_Loader $e) {
if (!$ignoreMissing) {
throw $e;
}
}
}
function twig_constant($constant, $object = null)
{
if (null !== $object) {
$constant = get_class($object).&#039;::&#039;.$constant;
}
return constant($constant);
}
function twig_array_batch($items, $size, $fill = null)
{
if ($items instanceof Traversable) {
$items = iterator_to_array($items, false);
}
$size = ceil($size);
$result = array_chunk($items, $size, true);
if (null !== $fill &amp;&amp; !empty($result)) {
$last = count($result) - 1;
if ($fillCount = $size - count($result[$last])) {
$result[$last] = array_merge(
$result[$last],
array_fill(0, $fillCount, $fill)
);
}
}
return $result;
}
}
namespace
{
class Twig_Extension_Escaper extends Twig_Extension
{
protected $defaultStrategy;
public function __construct($defaultStrategy =&#039;html&#039;)
{
$this-&gt;setDefaultStrategy($defaultStrategy);
}
public function getTokenParsers()
{
return array(new Twig_TokenParser_AutoEscape());
}
public function getNodeVisitors()
{
return array(new Twig_NodeVisitor_Escaper());
}
public function getFilters()
{
return array(
new Twig_SimpleFilter(&#039;raw&#039;,&#039;twig_raw_filter&#039;, array(&#039;is_safe&#039;=&gt; array(&#039;all&#039;))),
);
}
public function setDefaultStrategy($defaultStrategy)
{
if (true === $defaultStrategy) {
@trigger_error(&#039;Using &quot;true&quot; as the default strategy is deprecated since version 1.21. Use &quot;html&quot; instead.&#039;, E_USER_DEPRECATED);
$defaultStrategy =&#039;html&#039;;
}
if (&#039;filename&#039;=== $defaultStrategy) {
$defaultStrategy = array(&#039;Twig_FileExtensionEscapingStrategy&#039;,&#039;guess&#039;);
}
$this-&gt;defaultStrategy = $defaultStrategy;
}
public function getDefaultStrategy($filename)
{
if (!is_string($this-&gt;defaultStrategy) &amp;&amp; false !== $this-&gt;defaultStrategy) {
return call_user_func($this-&gt;defaultStrategy, $filename);
}
return $this-&gt;defaultStrategy;
}
public function getName()
{
return&#039;escaper&#039;;
}
}
function twig_raw_filter($string)
{
return $string;
}
}
namespace
{
class Twig_Extension_Optimizer extends Twig_Extension
{
protected $optimizers;
public function __construct($optimizers = -1)
{
$this-&gt;optimizers = $optimizers;
}
public function getNodeVisitors()
{
return array(new Twig_NodeVisitor_Optimizer($this-&gt;optimizers));
}
public function getName()
{
return&#039;optimizer&#039;;
}
}
}
namespace
{
interface Twig_LoaderInterface
{
public function getSource($name);
public function getCacheKey($name);
public function isFresh($name, $time);
}
}
namespace
{
class Twig_Markup implements Countable
{
protected $content;
protected $charset;
public function __construct($content, $charset)
{
$this-&gt;content = (string) $content;
$this-&gt;charset = $charset;
}
public function __toString()
{
return $this-&gt;content;
}
public function count()
{
return function_exists(&#039;mb_get_info&#039;) ? mb_strlen($this-&gt;content, $this-&gt;charset) : strlen($this-&gt;content);
}
}
}
namespace
{
interface Twig_TemplateInterface
{
const ANY_CALL =&#039;any&#039;;
const ARRAY_CALL =&#039;array&#039;;
const METHOD_CALL =&#039;method&#039;;
public function render(array $context);
public function display(array $context, array $blocks = array());
public function getEnvironment();
}
}
namespace
{
abstract class Twig_Template implements Twig_TemplateInterface
{
protected static $cache = array();
protected $parent;
protected $parents = array();
protected $env;
protected $blocks = array();
protected $traits = array();
public function __construct(Twig_Environment $env)
{
$this-&gt;env = $env;
}
abstract public function getTemplateName();
public function getEnvironment()
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method is deprecated since version 1.20 and will be removed in 2.0.&#039;, E_USER_DEPRECATED);
return $this-&gt;env;
}
public function getParent(array $context)
{
if (null !== $this-&gt;parent) {
return $this-&gt;parent;
}
try {
$parent = $this-&gt;doGetParent($context);
if (false === $parent) {
return false;
}
if ($parent instanceof self) {
return $this-&gt;parents[$parent-&gt;getTemplateName()] = $parent;
}
if (!isset($this-&gt;parents[$parent])) {
$this-&gt;parents[$parent] = $this-&gt;loadTemplate($parent);
}
} catch (Twig_Error_Loader $e) {
$e-&gt;setTemplateFile(null);
$e-&gt;guess();
throw $e;
}
return $this-&gt;parents[$parent];
}
protected function doGetParent(array $context)
{
return false;
}
public function isTraitable()
{
return true;
}
public function displayParentBlock($name, array $context, array $blocks = array())
{
$name = (string) $name;
if (isset($this-&gt;traits[$name])) {
$this-&gt;traits[$name][0]-&gt;displayBlock($name, $context, $blocks, false);
} elseif (false !== $parent = $this-&gt;getParent($context)) {
$parent-&gt;displayBlock($name, $context, $blocks, false);
} else {
throw new Twig_Error_Runtime(sprintf(&#039;The template has no parent and no traits defining the &quot;%s&quot; block&#039;, $name), -1, $this-&gt;getTemplateName());
}
}
public function displayBlock($name, array $context, array $blocks = array(), $useBlocks = true)
{
$name = (string) $name;
if ($useBlocks &amp;&amp; isset($blocks[$name])) {
$template = $blocks[$name][0];
$block = $blocks[$name][1];
} elseif (isset($this-&gt;blocks[$name])) {
$template = $this-&gt;blocks[$name][0];
$block = $this-&gt;blocks[$name][1];
} else {
$template = null;
$block = null;
}
if (null !== $template) {
if (!$template instanceof self) {
throw new LogicException(&#039;A block must be a method on a Twig_Template instance.&#039;);
}
try {
$template-&gt;$block($context, $blocks);
} catch (Twig_Error $e) {
if (!$e-&gt;getTemplateFile()) {
$e-&gt;setTemplateFile($template-&gt;getTemplateName());
}
if (false === $e-&gt;getTemplateLine()) {
$e-&gt;setTemplateLine(-1);
$e-&gt;guess();
}
throw $e;
} catch (Exception $e) {
throw new Twig_Error_Runtime(sprintf(&#039;An exception has been thrown during the rendering of a template (&quot;%s&quot;).&#039;, $e-&gt;getMessage()), -1, $template-&gt;getTemplateName(), $e);
}
} elseif (false !== $parent = $this-&gt;getParent($context)) {
$parent-&gt;displayBlock($name, $context, array_merge($this-&gt;blocks, $blocks), false);
}
}
public function renderParentBlock($name, array $context, array $blocks = array())
{
ob_start();
$this-&gt;displayParentBlock($name, $context, $blocks);
return ob_get_clean();
}
public function renderBlock($name, array $context, array $blocks = array(), $useBlocks = true)
{
ob_start();
$this-&gt;displayBlock($name, $context, $blocks, $useBlocks);
return ob_get_clean();
}
public function hasBlock($name)
{
return isset($this-&gt;blocks[(string) $name]);
}
public function getBlockNames()
{
return array_keys($this-&gt;blocks);
}
protected function loadTemplate($template, $templateName = null, $line = null, $index = null)
{
try {
if (is_array($template)) {
return $this-&gt;env-&gt;resolveTemplate($template);
}
if ($template instanceof self) {
return $template;
}
return $this-&gt;env-&gt;loadTemplate($template, $index);
} catch (Twig_Error $e) {
if (!$e-&gt;getTemplateFile()) {
$e-&gt;setTemplateFile($templateName ? $templateName : $this-&gt;getTemplateName());
}
if ($e-&gt;getTemplateLine()) {
throw $e;
}
if (!$line) {
$e-&gt;guess();
} else {
$e-&gt;setTemplateLine($line);
}
throw $e;
}
}
public function getBlocks()
{
return $this-&gt;blocks;
}
public function getSource()
{
$reflector = new ReflectionClass($this);
$file = $reflector-&gt;getFileName();
if (!file_exists($file)) {
return;
}
$source = file($file, FILE_IGNORE_NEW_LINES);
array_splice($source, 0, $reflector-&gt;getEndLine());
$i = 0;
while (isset($source[$i]) &amp;&amp;&#039;/* */&#039;=== substr_replace($source[$i],&#039;&#039;, 3, -2)) {
$source[$i] = str_replace(&#039;*//* &#039;,&#039;*/&#039;, substr($source[$i], 3, -2));
++$i;
}
array_splice($source, $i);
return implode(&quot;\n&quot;, $source);
}
public function display(array $context, array $blocks = array())
{
$this-&gt;displayWithErrorHandling($this-&gt;env-&gt;mergeGlobals($context), array_merge($this-&gt;blocks, $blocks));
}
public function render(array $context)
{
$level = ob_get_level();
ob_start();
try {
$this-&gt;display($context);
} catch (Exception $e) {
while (ob_get_level() &gt; $level) {
ob_end_clean();
}
throw $e;
}
return ob_get_clean();
}
protected function displayWithErrorHandling(array $context, array $blocks = array())
{
try {
$this-&gt;doDisplay($context, $blocks);
} catch (Twig_Error $e) {
if (!$e-&gt;getTemplateFile()) {
$e-&gt;setTemplateFile($this-&gt;getTemplateName());
}
if (false === $e-&gt;getTemplateLine()) {
$e-&gt;setTemplateLine(-1);
$e-&gt;guess();
}
throw $e;
} catch (Exception $e) {
throw new Twig_Error_Runtime(sprintf(&#039;An exception has been thrown during the rendering of a template (&quot;%s&quot;).&#039;, $e-&gt;getMessage()), -1, $this-&gt;getTemplateName(), $e);
}
}
abstract protected function doDisplay(array $context, array $blocks = array());
final protected function getContext($context, $item, $ignoreStrictCheck = false)
{
if (!array_key_exists($item, $context)) {
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return;
}
throw new Twig_Error_Runtime(sprintf(&#039;Variable &quot;%s&quot; does not exist&#039;, $item), -1, $this-&gt;getTemplateName());
}
return $context[$item];
}
protected function getAttribute($object, $item, array $arguments = array(), $type = self::ANY_CALL, $isDefinedTest = false, $ignoreStrictCheck = false)
{
if (self::METHOD_CALL !== $type) {
$arrayItem = is_bool($item) || is_float($item) ? (int) $item : $item;
if ((is_array($object) &amp;&amp; array_key_exists($arrayItem, $object))
|| ($object instanceof ArrayAccess &amp;&amp; isset($object[$arrayItem]))
) {
if ($isDefinedTest) {
return true;
}
return $object[$arrayItem];
}
if (self::ARRAY_CALL === $type || !is_object($object)) {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return;
}
if ($object instanceof ArrayAccess) {
$message = sprintf(&#039;Key &quot;%s&quot; in object with ArrayAccess of class &quot;%s&quot; does not exist&#039;, $arrayItem, get_class($object));
} elseif (is_object($object)) {
$message = sprintf(&#039;Impossible to access a key &quot;%s&quot; on an object of class &quot;%s&quot; that does not implement ArrayAccess interface&#039;, $item, get_class($object));
} elseif (is_array($object)) {
if (empty($object)) {
$message = sprintf(&#039;Key &quot;%s&quot; does not exist as the array is empty&#039;, $arrayItem);
} else {
$message = sprintf(&#039;Key &quot;%s&quot; for array with keys &quot;%s&quot; does not exist&#039;, $arrayItem, implode(&#039;, &#039;, array_keys($object)));
}
} elseif (self::ARRAY_CALL === $type) {
if (null === $object) {
$message = sprintf(&#039;Impossible to access a key (&quot;%s&quot;) on a null variable&#039;, $item);
} else {
$message = sprintf(&#039;Impossible to access a key (&quot;%s&quot;) on a %s variable (&quot;%s&quot;)&#039;, $item, gettype($object), $object);
}
} elseif (null === $object) {
$message = sprintf(&#039;Impossible to access an attribute (&quot;%s&quot;) on a null variable&#039;, $item);
} else {
$message = sprintf(&#039;Impossible to access an attribute (&quot;%s&quot;) on a %s variable (&quot;%s&quot;)&#039;, $item, gettype($object), $object);
}
throw new Twig_Error_Runtime($message, -1, $this-&gt;getTemplateName());
}
}
if (!is_object($object)) {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return;
}
if (null === $object) {
$message = sprintf(&#039;Impossible to invoke a method (&quot;%s&quot;) on a null variable&#039;, $item);
} else {
$message = sprintf(&#039;Impossible to invoke a method (&quot;%s&quot;) on a %s variable (&quot;%s&quot;)&#039;, $item, gettype($object), $object);
}
throw new Twig_Error_Runtime($message, -1, $this-&gt;getTemplateName());
}
if (self::METHOD_CALL !== $type &amp;&amp; !$object instanceof self) { if (isset($object-&gt;$item) || array_key_exists((string) $item, $object)) {
if ($isDefinedTest) {
return true;
}
if ($this-&gt;env-&gt;hasExtension(&#039;sandbox&#039;)) {
$this-&gt;env-&gt;getExtension(&#039;sandbox&#039;)-&gt;checkPropertyAllowed($object, $item);
}
return $object-&gt;$item;
}
}
$class = get_class($object);
if (!isset(self::$cache[$class][&#039;methods&#039;])) {
if ($object instanceof self) {
$ref = new ReflectionClass($class);
$methods = array();
foreach ($ref-&gt;getMethods(ReflectionMethod::IS_PUBLIC) as $refMethod) {
$methodName = strtolower($refMethod-&gt;name);
if (&#039;getenvironment&#039;!== $methodName) {
$methods[$methodName] = true;
}
}
self::$cache[$class][&#039;methods&#039;] = $methods;
} else {
self::$cache[$class][&#039;methods&#039;] = array_change_key_case(array_flip(get_class_methods($object)));
}
}
$call = false;
$lcItem = strtolower($item);
if (isset(self::$cache[$class][&#039;methods&#039;][$lcItem])) {
$method = (string) $item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;get&#039;.$lcItem])) {
$method =&#039;get&#039;.$item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;is&#039;.$lcItem])) {
$method =&#039;is&#039;.$item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;__call&#039;])) {
$method = (string) $item;
$call = true;
} else {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return;
}
throw new Twig_Error_Runtime(sprintf(&#039;Method &quot;%s&quot; for object &quot;%s&quot; does not exist&#039;, $item, get_class($object)), -1, $this-&gt;getTemplateName());
}
if ($isDefinedTest) {
return true;
}
if ($this-&gt;env-&gt;hasExtension(&#039;sandbox&#039;)) {
$this-&gt;env-&gt;getExtension(&#039;sandbox&#039;)-&gt;checkMethodAllowed($object, $method);
}
try {
$ret = call_user_func_array(array($object, $method), $arguments);
} catch (BadMethodCallException $e) {
if ($call &amp;&amp; ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables())) {
return;
}
throw $e;
}
if ($object instanceof Twig_TemplateInterface) {
return $ret ===&#039;&#039;?&#039;&#039;: new Twig_Markup($ret, $this-&gt;env-&gt;getCharset());
}
return $ret;
}
}
}
namespace Monolog\Formatter
{
interface FormatterInterface
{
public function format(array $record);
public function formatBatch(array $records);
}
}
namespace Monolog\Formatter
{
use Exception;
class NormalizerFormatter implements FormatterInterface
{
const SIMPLE_DATE =&quot;Y-m-d H:i:s&quot;;
protected $dateFormat;
public function __construct($dateFormat = null)
{
$this-&gt;dateFormat = $dateFormat ?: static::SIMPLE_DATE;
if (!function_exists(&#039;json_encode&#039;)) {
throw new \RuntimeException(&#039;PHP\&#039;s json extension is required to use Monolog\&#039;s NormalizerFormatter&#039;);
}
}
public function format(array $record)
{
return $this-&gt;normalize($record);
}
public function formatBatch(array $records)
{
foreach ($records as $key =&gt; $record) {
$records[$key] = $this-&gt;format($record);
}
return $records;
}
protected function normalize($data)
{
if (null === $data || is_scalar($data)) {
if (is_float($data)) {
if (is_infinite($data)) {
return ($data &gt; 0 ?&#039;&#039;:&#039;-&#039;) .&#039;INF&#039;;
}
if (is_nan($data)) {
return&#039;NaN&#039;;
}
}
return $data;
}
if (is_array($data) || $data instanceof \Traversable) {
$normalized = array();
$count = 1;
foreach ($data as $key =&gt; $value) {
if ($count++ &gt;= 1000) {
$normalized[&#039;...&#039;] =&#039;Over 1000 items, aborting normalization&#039;;
break;
}
$normalized[$key] = $this-&gt;normalize($value);
}
return $normalized;
}
if ($data instanceof \DateTime) {
return $data-&gt;format($this-&gt;dateFormat);
}
if (is_object($data)) {
if ($data instanceof Exception || (PHP_VERSION_ID &gt; 70000 &amp;&amp; $data instanceof \Throwable)) {
return $this-&gt;normalizeException($data);
}
if (method_exists($data,&#039;__toString&#039;) &amp;&amp; !$data instanceof \JsonSerializable) {
$value = $data-&gt;__toString();
} else {
$value = $this-&gt;toJson($data, true);
}
return sprintf(&quot;[object] (%s: %s)&quot;, get_class($data), $value);
}
if (is_resource($data)) {
return sprintf(&#039;[resource] (%s)&#039;, get_resource_type($data));
}
return&#039;[unknown(&#039;.gettype($data).&#039;)]&#039;;
}
protected function normalizeException($e)
{
if (!$e instanceof Exception &amp;&amp; !$e instanceof \Throwable) {
throw new \InvalidArgumentException(&#039;Exception/Throwable expected, got &#039;.gettype($e).&#039; / &#039;.get_class($e));
}
$data = array(&#039;class&#039;=&gt; get_class($e),&#039;message&#039;=&gt; $e-&gt;getMessage(),&#039;code&#039;=&gt; $e-&gt;getCode(),&#039;file&#039;=&gt; $e-&gt;getFile().&#039;:&#039;.$e-&gt;getLine(),
);
$trace = $e-&gt;getTrace();
foreach ($trace as $frame) {
if (isset($frame[&#039;file&#039;])) {
$data[&#039;trace&#039;][] = $frame[&#039;file&#039;].&#039;:&#039;.$frame[&#039;line&#039;];
} else {
$data[&#039;trace&#039;][] = $this-&gt;toJson($this-&gt;normalize($frame), true);
}
}
if ($previous = $e-&gt;getPrevious()) {
$data[&#039;previous&#039;] = $this-&gt;normalizeException($previous);
}
return $data;
}
protected function toJson($data, $ignoreErrors = false)
{
if ($ignoreErrors) {
return @$this-&gt;jsonEncode($data);
}
$json = $this-&gt;jsonEncode($data);
if ($json === false) {
$json = $this-&gt;handleJsonError(json_last_error(), $data);
}
return $json;
}
private function jsonEncode($data)
{
if (version_compare(PHP_VERSION,&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return json_encode($data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
}
return json_encode($data);
}
private function handleJsonError($code, $data)
{
if ($code !== JSON_ERROR_UTF8) {
$this-&gt;throwEncodeError($code, $data);
}
if (is_string($data)) {
$this-&gt;detectAndCleanUtf8($data);
} elseif (is_array($data)) {
array_walk_recursive($data, array($this,&#039;detectAndCleanUtf8&#039;));
} else {
$this-&gt;throwEncodeError($code, $data);
}
$json = $this-&gt;jsonEncode($data);
if ($json === false) {
$this-&gt;throwEncodeError(json_last_error(), $data);
}
return $json;
}
private function throwEncodeError($code, $data)
{
switch ($code) {
case JSON_ERROR_DEPTH:
$msg =&#039;Maximum stack depth exceeded&#039;;
break;
case JSON_ERROR_STATE_MISMATCH:
$msg =&#039;Underflow or the modes mismatch&#039;;
break;
case JSON_ERROR_CTRL_CHAR:
$msg =&#039;Unexpected control character found&#039;;
break;
case JSON_ERROR_UTF8:
$msg =&#039;Malformed UTF-8 characters, possibly incorrectly encoded&#039;;
break;
default:
$msg =&#039;Unknown error&#039;;
}
throw new \RuntimeException(&#039;JSON encoding failed: &#039;.$msg.&#039;. Encoding: &#039;.var_export($data, true));
}
public function detectAndCleanUtf8(&amp;$data)
{
if (is_string($data) &amp;&amp; !preg_match(&#039;//u&#039;, $data)) {
$data = preg_replace_callback(&#039;/[\x80-\xFF]+/&#039;,
function ($m) { return utf8_encode($m[0]); },
$data
);
$data = str_replace(
array(&#039;¤&#039;,&#039;¦&#039;,&#039;¨&#039;,&#039;´&#039;,&#039;¸&#039;,&#039;¼&#039;,&#039;½&#039;,&#039;¾&#039;),
array(&#039;€&#039;,&#039;Š&#039;,&#039;š&#039;,&#039;Ž&#039;,&#039;ž&#039;,&#039;Œ&#039;,&#039;œ&#039;,&#039;Ÿ&#039;),
$data
);
}
}
}
}
namespace Monolog\Formatter
{
class LineFormatter extends NormalizerFormatter
{
const SIMPLE_FORMAT =&quot;[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n&quot;;
protected $format;
protected $allowInlineLineBreaks;
protected $ignoreEmptyContextAndExtra;
protected $includeStacktraces;
public function __construct($format = null, $dateFormat = null, $allowInlineLineBreaks = false, $ignoreEmptyContextAndExtra = false)
{
$this-&gt;format = $format ?: static::SIMPLE_FORMAT;
$this-&gt;allowInlineLineBreaks = $allowInlineLineBreaks;
$this-&gt;ignoreEmptyContextAndExtra = $ignoreEmptyContextAndExtra;
parent::__construct($dateFormat);
}
public function includeStacktraces($include = true)
{
$this-&gt;includeStacktraces = $include;
if ($this-&gt;includeStacktraces) {
$this-&gt;allowInlineLineBreaks = true;
}
}
public function allowInlineLineBreaks($allow = true)
{
$this-&gt;allowInlineLineBreaks = $allow;
}
public function ignoreEmptyContextAndExtra($ignore = true)
{
$this-&gt;ignoreEmptyContextAndExtra = $ignore;
}
public function format(array $record)
{
$vars = parent::format($record);
$output = $this-&gt;format;
foreach ($vars[&#039;extra&#039;] as $var =&gt; $val) {
if (false !== strpos($output,&#039;%extra.&#039;.$var.&#039;%&#039;)) {
$output = str_replace(&#039;%extra.&#039;.$var.&#039;%&#039;, $this-&gt;stringify($val), $output);
unset($vars[&#039;extra&#039;][$var]);
}
}
foreach ($vars[&#039;context&#039;] as $var =&gt; $val) {
if (false !== strpos($output,&#039;%context.&#039;.$var.&#039;%&#039;)) {
$output = str_replace(&#039;%context.&#039;.$var.&#039;%&#039;, $this-&gt;stringify($val), $output);
unset($vars[&#039;context&#039;][$var]);
}
}
if ($this-&gt;ignoreEmptyContextAndExtra) {
if (empty($vars[&#039;context&#039;])) {
unset($vars[&#039;context&#039;]);
$output = str_replace(&#039;%context%&#039;,&#039;&#039;, $output);
}
if (empty($vars[&#039;extra&#039;])) {
unset($vars[&#039;extra&#039;]);
$output = str_replace(&#039;%extra%&#039;,&#039;&#039;, $output);
}
}
foreach ($vars as $var =&gt; $val) {
if (false !== strpos($output,&#039;%&#039;.$var.&#039;%&#039;)) {
$output = str_replace(&#039;%&#039;.$var.&#039;%&#039;, $this-&gt;stringify($val), $output);
}
}
return $output;
}
public function formatBatch(array $records)
{
$message =&#039;&#039;;
foreach ($records as $record) {
$message .= $this-&gt;format($record);
}
return $message;
}
public function stringify($value)
{
return $this-&gt;replaceNewlines($this-&gt;convertToString($value));
}
protected function normalizeException($e)
{
if (!$e instanceof \Exception &amp;&amp; !$e instanceof \Throwable) {
throw new \InvalidArgumentException(&#039;Exception/Throwable expected, got &#039;.gettype($e).&#039; / &#039;.get_class($e));
}
$previousText =&#039;&#039;;
if ($previous = $e-&gt;getPrevious()) {
do {
$previousText .=&#039;, &#039;.get_class($previous).&#039;(code: &#039;.$previous-&gt;getCode().&#039;): &#039;.$previous-&gt;getMessage().&#039; at &#039;.$previous-&gt;getFile().&#039;:&#039;.$previous-&gt;getLine();
} while ($previous = $previous-&gt;getPrevious());
}
$str =&#039;[object] (&#039;.get_class($e).&#039;(code: &#039;.$e-&gt;getCode().&#039;): &#039;.$e-&gt;getMessage().&#039; at &#039;.$e-&gt;getFile().&#039;:&#039;.$e-&gt;getLine().$previousText.&#039;)&#039;;
if ($this-&gt;includeStacktraces) {
$str .=&quot;\n[stacktrace]\n&quot;.$e-&gt;getTraceAsString();
}
return $str;
}
protected function convertToString($data)
{
if (null === $data || is_bool($data)) {
return var_export($data, true);
}
if (is_scalar($data)) {
return (string) $data;
}
if (version_compare(PHP_VERSION,&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return $this-&gt;toJson($data, true);
}
return str_replace(&#039;\\/&#039;,&#039;/&#039;, @json_encode($data));
}
protected function replaceNewlines($str)
{
if ($this-&gt;allowInlineLineBreaks) {
return $str;
}
return str_replace(array(&quot;\r\n&quot;,&quot;\r&quot;,&quot;\n&quot;),&#039; &#039;, $str);
}
}
}
namespace Monolog\Handler
{
use Monolog\Formatter\FormatterInterface;
interface HandlerInterface
{
public function isHandling(array $record);
public function handle(array $record);
public function handleBatch(array $records);
public function pushProcessor($callback);
public function popProcessor();
public function setFormatter(FormatterInterface $formatter);
public function getFormatter();
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
use Monolog\Formatter\FormatterInterface;
use Monolog\Formatter\LineFormatter;
abstract class AbstractHandler implements HandlerInterface
{
protected $level = Logger::DEBUG;
protected $bubble = true;
protected $formatter;
protected $processors = array();
public function __construct($level = Logger::DEBUG, $bubble = true)
{
$this-&gt;setLevel($level);
$this-&gt;bubble = $bubble;
}
public function isHandling(array $record)
{
return $record[&#039;level&#039;] &gt;= $this-&gt;level;
}
public function handleBatch(array $records)
{
foreach ($records as $record) {
$this-&gt;handle($record);
}
}
public function close()
{
}
public function pushProcessor($callback)
{
if (!is_callable($callback)) {
throw new \InvalidArgumentException(&#039;Processors must be valid callables (callback or object with an __invoke method), &#039;.var_export($callback, true).&#039; given&#039;);
}
array_unshift($this-&gt;processors, $callback);
return $this;
}
public function popProcessor()
{
if (!$this-&gt;processors) {
throw new \LogicException(&#039;You tried to pop from an empty processor stack.&#039;);
}
return array_shift($this-&gt;processors);
}
public function setFormatter(FormatterInterface $formatter)
{
$this-&gt;formatter = $formatter;
return $this;
}
public function getFormatter()
{
if (!$this-&gt;formatter) {
$this-&gt;formatter = $this-&gt;getDefaultFormatter();
}
return $this-&gt;formatter;
}
public function setLevel($level)
{
$this-&gt;level = Logger::toMonologLevel($level);
return $this;
}
public function getLevel()
{
return $this-&gt;level;
}
public function setBubble($bubble)
{
$this-&gt;bubble = $bubble;
return $this;
}
public function getBubble()
{
return $this-&gt;bubble;
}
public function __destruct()
{
try {
$this-&gt;close();
} catch (\Exception $e) {
}
}
protected function getDefaultFormatter()
{
return new LineFormatter();
}
}
}
namespace Monolog\Handler
{
abstract class AbstractProcessingHandler extends AbstractHandler
{
public function handle(array $record)
{
if (!$this-&gt;isHandling($record)) {
return false;
}
$record = $this-&gt;processRecord($record);
$record[&#039;formatted&#039;] = $this-&gt;getFormatter()-&gt;format($record);
$this-&gt;write($record);
return false === $this-&gt;bubble;
}
abstract protected function write(array $record);
protected function processRecord(array $record)
{
if ($this-&gt;processors) {
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
}
return $record;
}
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
class StreamHandler extends AbstractProcessingHandler
{
protected $stream;
protected $url;
private $errorMessage;
protected $filePermission;
protected $useLocking;
private $dirCreated;
public function __construct($stream, $level = Logger::DEBUG, $bubble = true, $filePermission = null, $useLocking = false)
{
parent::__construct($level, $bubble);
if (is_resource($stream)) {
$this-&gt;stream = $stream;
} elseif (is_string($stream)) {
$this-&gt;url = $stream;
} else {
throw new \InvalidArgumentException(&#039;A stream must either be a resource or a string.&#039;);
}
$this-&gt;filePermission = $filePermission;
$this-&gt;useLocking = $useLocking;
}
public function close()
{
if (is_resource($this-&gt;stream)) {
fclose($this-&gt;stream);
}
$this-&gt;stream = null;
}
protected function write(array $record)
{
if (!is_resource($this-&gt;stream)) {
if (!$this-&gt;url) {
throw new \LogicException(&#039;Missing stream url, the stream can not be opened. This may be caused by a premature call to close().&#039;);
}
$this-&gt;createDir();
$this-&gt;errorMessage = null;
set_error_handler(array($this,&#039;customErrorHandler&#039;));
$this-&gt;stream = fopen($this-&gt;url,&#039;a&#039;);
if ($this-&gt;filePermission !== null) {
@chmod($this-&gt;url, $this-&gt;filePermission);
}
restore_error_handler();
if (!is_resource($this-&gt;stream)) {
$this-&gt;stream = null;
throw new \UnexpectedValueException(sprintf(&#039;The stream or file &quot;%s&quot; could not be opened: &#039;.$this-&gt;errorMessage, $this-&gt;url));
}
}
if ($this-&gt;useLocking) {
flock($this-&gt;stream, LOCK_EX);
}
fwrite($this-&gt;stream, (string) $record[&#039;formatted&#039;]);
if ($this-&gt;useLocking) {
flock($this-&gt;stream, LOCK_UN);
}
}
private function customErrorHandler($code, $msg)
{
$this-&gt;errorMessage = preg_replace(&#039;{^(fopen|mkdir)\(.*?\): }&#039;,&#039;&#039;, $msg);
}
private function getDirFromStream($stream)
{
$pos = strpos($stream,&#039;://&#039;);
if ($pos === false) {
return dirname($stream);
}
if (&#039;file://&#039;=== substr($stream, 0, 7)) {
return dirname(substr($stream, 7));
}
return;
}
private function createDir()
{
if ($this-&gt;dirCreated) {
return;
}
$dir = $this-&gt;getDirFromStream($this-&gt;url);
if (null !== $dir &amp;&amp; !is_dir($dir)) {
$this-&gt;errorMessage = null;
set_error_handler(array($this,&#039;customErrorHandler&#039;));
$status = mkdir($dir, 0777, true);
restore_error_handler();
if (false === $status) {
throw new \UnexpectedValueException(sprintf(&#039;There is no existing directory at &quot;%s&quot; and its not buildable: &#039;.$this-&gt;errorMessage, $dir));
}
}
$this-&gt;dirCreated = true;
}
}
}
namespace Monolog\Handler
{
use Monolog\Handler\FingersCrossed\ErrorLevelActivationStrategy;
use Monolog\Handler\FingersCrossed\ActivationStrategyInterface;
use Monolog\Logger;
class FingersCrossedHandler extends AbstractHandler
{
protected $handler;
protected $activationStrategy;
protected $buffering = true;
protected $bufferSize;
protected $buffer = array();
protected $stopBuffering;
protected $passthruLevel;
public function __construct($handler, $activationStrategy = null, $bufferSize = 0, $bubble = true, $stopBuffering = true, $passthruLevel = null)
{
if (null === $activationStrategy) {
$activationStrategy = new ErrorLevelActivationStrategy(Logger::WARNING);
}
if (!$activationStrategy instanceof ActivationStrategyInterface) {
$activationStrategy = new ErrorLevelActivationStrategy($activationStrategy);
}
$this-&gt;handler = $handler;
$this-&gt;activationStrategy = $activationStrategy;
$this-&gt;bufferSize = $bufferSize;
$this-&gt;bubble = $bubble;
$this-&gt;stopBuffering = $stopBuffering;
if ($passthruLevel !== null) {
$this-&gt;passthruLevel = Logger::toMonologLevel($passthruLevel);
}
if (!$this-&gt;handler instanceof HandlerInterface &amp;&amp; !is_callable($this-&gt;handler)) {
throw new \RuntimeException(&quot;The given handler (&quot;.json_encode($this-&gt;handler).&quot;) is not a callable nor a Monolog\Handler\HandlerInterface object&quot;);
}
}
public function isHandling(array $record)
{
return true;
}
public function handle(array $record)
{
if ($this-&gt;processors) {
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
}
if ($this-&gt;buffering) {
$this-&gt;buffer[] = $record;
if ($this-&gt;bufferSize &gt; 0 &amp;&amp; count($this-&gt;buffer) &gt; $this-&gt;bufferSize) {
array_shift($this-&gt;buffer);
}
if ($this-&gt;activationStrategy-&gt;isHandlerActivated($record)) {
if ($this-&gt;stopBuffering) {
$this-&gt;buffering = false;
}
if (!$this-&gt;handler instanceof HandlerInterface) {
$this-&gt;handler = call_user_func($this-&gt;handler, $record, $this);
if (!$this-&gt;handler instanceof HandlerInterface) {
throw new \RuntimeException(&quot;The factory callable should return a HandlerInterface&quot;);
}
}
$this-&gt;handler-&gt;handleBatch($this-&gt;buffer);
$this-&gt;buffer = array();
}
} else {
$this-&gt;handler-&gt;handle($record);
}
return false === $this-&gt;bubble;
}
public function close()
{
if (null !== $this-&gt;passthruLevel) {
$level = $this-&gt;passthruLevel;
$this-&gt;buffer = array_filter($this-&gt;buffer, function ($record) use ($level) {
return $record[&#039;level&#039;] &gt;= $level;
});
if (count($this-&gt;buffer) &gt; 0) {
$this-&gt;handler-&gt;handleBatch($this-&gt;buffer);
$this-&gt;buffer = array();
}
}
}
public function reset()
{
$this-&gt;buffering = true;
}
public function clear()
{
$this-&gt;buffer = array();
$this-&gt;reset();
}
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
class FilterHandler extends AbstractHandler
{
protected $handler;
protected $acceptedLevels;
protected $bubble;
public function __construct($handler, $minLevelOrList = Logger::DEBUG, $maxLevel = Logger::EMERGENCY, $bubble = true)
{
$this-&gt;handler = $handler;
$this-&gt;bubble = $bubble;
$this-&gt;setAcceptedLevels($minLevelOrList, $maxLevel);
if (!$this-&gt;handler instanceof HandlerInterface &amp;&amp; !is_callable($this-&gt;handler)) {
throw new \RuntimeException(&quot;The given handler (&quot;.json_encode($this-&gt;handler).&quot;) is not a callable nor a Monolog\Handler\HandlerInterface object&quot;);
}
}
public function getAcceptedLevels()
{
return array_flip($this-&gt;acceptedLevels);
}
public function setAcceptedLevels($minLevelOrList = Logger::DEBUG, $maxLevel = Logger::EMERGENCY)
{
if (is_array($minLevelOrList)) {
$acceptedLevels = array_map(&#039;Monolog\Logger::toMonologLevel&#039;, $minLevelOrList);
} else {
$minLevelOrList = Logger::toMonologLevel($minLevelOrList);
$maxLevel = Logger::toMonologLevel($maxLevel);
$acceptedLevels = array_values(array_filter(Logger::getLevels(), function ($level) use ($minLevelOrList, $maxLevel) {
return $level &gt;= $minLevelOrList &amp;&amp; $level &lt;= $maxLevel;
}));
}
$this-&gt;acceptedLevels = array_flip($acceptedLevels);
}
public function isHandling(array $record)
{
return isset($this-&gt;acceptedLevels[$record[&#039;level&#039;]]);
}
public function handle(array $record)
{
if (!$this-&gt;isHandling($record)) {
return false;
}
if (!$this-&gt;handler instanceof HandlerInterface) {
$this-&gt;handler = call_user_func($this-&gt;handler, $record, $this);
if (!$this-&gt;handler instanceof HandlerInterface) {
throw new \RuntimeException(&quot;The factory callable should return a HandlerInterface&quot;);
}
}
if ($this-&gt;processors) {
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
}
$this-&gt;handler-&gt;handle($record);
return false === $this-&gt;bubble;
}
public function handleBatch(array $records)
{
$filtered = array();
foreach ($records as $record) {
if ($this-&gt;isHandling($record)) {
$filtered[] = $record;
}
}
$this-&gt;handler-&gt;handleBatch($filtered);
}
}
}
namespace Monolog\Handler
{
class TestHandler extends AbstractProcessingHandler
{
protected $records = array();
protected $recordsByLevel = array();
public function getRecords()
{
return $this-&gt;records;
}
protected function hasRecordRecords($level)
{
return isset($this-&gt;recordsByLevel[$level]);
}
protected function hasRecord($record, $level)
{
if (is_array($record)) {
$record = $record[&#039;message&#039;];
}
return $this-&gt;hasRecordThatPasses(function ($rec) use ($record) {
return $rec[&#039;message&#039;] === $record;
}, $level);
}
public function hasRecordThatContains($message, $level)
{
return $this-&gt;hasRecordThatPasses(function ($rec) use ($message) {
return strpos($rec[&#039;message&#039;], $message) !== false;
}, $level);
}
public function hasRecordThatMatches($regex, $level)
{
return $this-&gt;hasRecordThatPasses(function ($rec) use ($regex) {
return preg_match($regex, $rec[&#039;message&#039;]) &gt; 0;
}, $level);
}
public function hasRecordThatPasses($predicate, $level)
{
if (!is_callable($predicate)) {
throw new \InvalidArgumentException(&quot;Expected a callable for hasRecordThatSucceeds&quot;);
}
if (!isset($this-&gt;recordsByLevel[$level])) {
return false;
}
foreach ($this-&gt;recordsByLevel[$level] as $i =&gt; $rec) {
if (call_user_func($predicate, $rec, $i)) {
return true;
}
}
return false;
}
protected function write(array $record)
{
$this-&gt;recordsByLevel[$record[&#039;level&#039;]][] = $record;
$this-&gt;records[] = $record;
}
public function __call($method, $args)
{
if (preg_match(&#039;/(.*)(Debug|Info|Notice|Warning|Error|Critical|Alert|Emergency)(.*)/&#039;, $method, $matches) &gt; 0) {
$genericMethod = $matches[1] .&#039;Record&#039;. $matches[3];
$level = constant(&#039;Monolog\Logger::&#039;. strtoupper($matches[2]));
if (method_exists($this, $genericMethod)) {
$args[] = $level;
return call_user_func_array(array($this, $genericMethod), $args);
}
}
throw new \BadMethodCallException(&#039;Call to undefined method &#039;. get_class($this) .&#039;::&#039;. $method .&#039;()&#039;);
}
}
}
namespace Monolog
{
use Monolog\Handler\HandlerInterface;
use Monolog\Handler\StreamHandler;
use Psr\Log\LoggerInterface;
use Psr\Log\InvalidArgumentException;
class Logger implements LoggerInterface
{
const DEBUG = 100;
const INFO = 200;
const NOTICE = 250;
const WARNING = 300;
const ERROR = 400;
const CRITICAL = 500;
const ALERT = 550;
const EMERGENCY = 600;
const API = 1;
protected static $levels = array(
self::DEBUG =&gt;&#039;DEBUG&#039;,
self::INFO =&gt;&#039;INFO&#039;,
self::NOTICE =&gt;&#039;NOTICE&#039;,
self::WARNING =&gt;&#039;WARNING&#039;,
self::ERROR =&gt;&#039;ERROR&#039;,
self::CRITICAL =&gt;&#039;CRITICAL&#039;,
self::ALERT =&gt;&#039;ALERT&#039;,
self::EMERGENCY =&gt;&#039;EMERGENCY&#039;,
);
protected static $timezone;
protected $name;
protected $handlers;
protected $processors;
protected $microsecondTimestamps = true;
public function __construct($name, array $handlers = array(), array $processors = array())
{
$this-&gt;name = $name;
$this-&gt;handlers = $handlers;
$this-&gt;processors = $processors;
}
public function getName()
{
return $this-&gt;name;
}
public function withName($name)
{
$new = clone $this;
$new-&gt;name = $name;
return $new;
}
public function pushHandler(HandlerInterface $handler)
{
array_unshift($this-&gt;handlers, $handler);
return $this;
}
public function popHandler()
{
if (!$this-&gt;handlers) {
throw new \LogicException(&#039;You tried to pop from an empty handler stack.&#039;);
}
return array_shift($this-&gt;handlers);
}
public function setHandlers(array $handlers)
{
$this-&gt;handlers = array();
foreach (array_reverse($handlers) as $handler) {
$this-&gt;pushHandler($handler);
}
return $this;
}
public function getHandlers()
{
return $this-&gt;handlers;
}
public function pushProcessor($callback)
{
if (!is_callable($callback)) {
throw new \InvalidArgumentException(&#039;Processors must be valid callables (callback or object with an __invoke method), &#039;.var_export($callback, true).&#039; given&#039;);
}
array_unshift($this-&gt;processors, $callback);
return $this;
}
public function popProcessor()
{
if (!$this-&gt;processors) {
throw new \LogicException(&#039;You tried to pop from an empty processor stack.&#039;);
}
return array_shift($this-&gt;processors);
}
public function getProcessors()
{
return $this-&gt;processors;
}
public function useMicrosecondTimestamps($micro)
{
$this-&gt;microsecondTimestamps = (bool) $micro;
}
public function addRecord($level, $message, array $context = array())
{
if (!$this-&gt;handlers) {
$this-&gt;pushHandler(new StreamHandler(&#039;php://stderr&#039;, static::DEBUG));
}
$levelName = static::getLevelName($level);
$handlerKey = null;
reset($this-&gt;handlers);
while ($handler = current($this-&gt;handlers)) {
if ($handler-&gt;isHandling(array(&#039;level&#039;=&gt; $level))) {
$handlerKey = key($this-&gt;handlers);
break;
}
next($this-&gt;handlers);
}
if (null === $handlerKey) {
return false;
}
if (!static::$timezone) {
static::$timezone = new \DateTimeZone(date_default_timezone_get() ?:&#039;UTC&#039;);
}
if ($this-&gt;microsecondTimestamps) {
$ts = \DateTime::createFromFormat(&#039;U.u&#039;, sprintf(&#039;%.6F&#039;, microtime(true)), static::$timezone);
} else {
$ts = new \DateTime(null, static::$timezone);
}
$ts-&gt;setTimezone(static::$timezone);
$record = array(&#039;message&#039;=&gt; (string) $message,&#039;context&#039;=&gt; $context,&#039;level&#039;=&gt; $level,&#039;level_name&#039;=&gt; $levelName,&#039;channel&#039;=&gt; $this-&gt;name,&#039;datetime&#039;=&gt; $ts,&#039;extra&#039;=&gt; array(),
);
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
while ($handler = current($this-&gt;handlers)) {
if (true === $handler-&gt;handle($record)) {
break;
}
next($this-&gt;handlers);
}
return true;
}
public function addDebug($message, array $context = array())
{
return $this-&gt;addRecord(static::DEBUG, $message, $context);
}
public function addInfo($message, array $context = array())
{
return $this-&gt;addRecord(static::INFO, $message, $context);
}
public function addNotice($message, array $context = array())
{
return $this-&gt;addRecord(static::NOTICE, $message, $context);
}
public function addWarning($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function addError($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function addCritical($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function addAlert($message, array $context = array())
{
return $this-&gt;addRecord(static::ALERT, $message, $context);
}
public function addEmergency($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
public static function getLevels()
{
return array_flip(static::$levels);
}
public static function getLevelName($level)
{
if (!isset(static::$levels[$level])) {
throw new InvalidArgumentException(&#039;Level &quot;&#039;.$level.&#039;&quot; is not defined, use one of: &#039;.implode(&#039;, &#039;, array_keys(static::$levels)));
}
return static::$levels[$level];
}
public static function toMonologLevel($level)
{
if (is_string($level) &amp;&amp; defined(__CLASS__.&#039;::&#039;.strtoupper($level))) {
return constant(__CLASS__.&#039;::&#039;.strtoupper($level));
}
return $level;
}
public function isHandling($level)
{
$record = array(&#039;level&#039;=&gt; $level,
);
foreach ($this-&gt;handlers as $handler) {
if ($handler-&gt;isHandling($record)) {
return true;
}
}
return false;
}
public function log($level, $message, array $context = array())
{
$level = static::toMonologLevel($level);
return $this-&gt;addRecord($level, $message, $context);
}
public function debug($message, array $context = array())
{
return $this-&gt;addRecord(static::DEBUG, $message, $context);
}
public function info($message, array $context = array())
{
return $this-&gt;addRecord(static::INFO, $message, $context);
}
public function notice($message, array $context = array())
{
return $this-&gt;addRecord(static::NOTICE, $message, $context);
}
public function warn($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function warning($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function err($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function error($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function crit($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function critical($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function alert($message, array $context = array())
{
return $this-&gt;addRecord(static::ALERT, $message, $context);
}
public function emerg($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
public function emergency($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
public static function setTimezone(\DateTimeZone $tz)
{
self::$timezone = $tz;
}
}
}
namespace Symfony\Component\HttpKernel\Log
{
use Psr\Log\LoggerInterface as PsrLogger;
interface LoggerInterface extends PsrLogger
{
public function emerg($message, array $context = array());
public function crit($message, array $context = array());
public function err($message, array $context = array());
public function warn($message, array $context = array());
}
}
namespace Symfony\Component\HttpKernel\Log
{
interface DebugLoggerInterface
{
public function getLogs();
public function countErrors();
}
}
namespace Symfony\Bridge\Monolog
{
use Monolog\Logger as BaseLogger;
use Symfony\Component\HttpKernel\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Log\DebugLoggerInterface;
class Logger extends BaseLogger implements LoggerInterface, DebugLoggerInterface
{
public function emerg($message, array $context = array())
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method inherited from the Symfony\Component\HttpKernel\Log\LoggerInterface interface is deprecated since version 2.2 and will be removed in 3.0. Use the emergency() method instead, which is PSR-3 compatible.&#039;, E_USER_DEPRECATED);
return parent::addRecord(BaseLogger::EMERGENCY, $message, $context);
}
public function crit($message, array $context = array())
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method inherited from the Symfony\Component\HttpKernel\Log\LoggerInterface interface is deprecated since version 2.2 and will be removed in 3.0. Use the method critical() method instead, which is PSR-3 compatible.&#039;, E_USER_DEPRECATED);
return parent::addRecord(BaseLogger::CRITICAL, $message, $context);
}
public function err($message, array $context = array())
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method inherited from the Symfony\Component\HttpKernel\Log\LoggerInterface interface is deprecated since version 2.2 and will be removed in 3.0. Use the error() method instead, which is PSR-3 compatible.&#039;, E_USER_DEPRECATED);
return parent::addRecord(BaseLogger::ERROR, $message, $context);
}
public function warn($message, array $context = array())
{
@trigger_error(&#039;The &#039;.__METHOD__.&#039; method inherited from the Symfony\Component\HttpKernel\Log\LoggerInterface interface is deprecated since version 2.2 and will be removed in 3.0. Use the warning() method instead, which is PSR-3 compatible.&#039;, E_USER_DEPRECATED);
return parent::addRecord(BaseLogger::WARNING, $message, $context);
}
public function getLogs()
{
if ($logger = $this-&gt;getDebugLogger()) {
return $logger-&gt;getLogs();
}
return array();
}
public function countErrors()
{
if ($logger = $this-&gt;getDebugLogger()) {
return $logger-&gt;countErrors();
}
return 0;
}
private function getDebugLogger()
{
foreach ($this-&gt;handlers as $handler) {
if ($handler instanceof DebugLoggerInterface) {
return $handler;
}
}
}
}
}
namespace Symfony\Bridge\Monolog\Handler
{
use Monolog\Logger;
use Monolog\Handler\TestHandler;
use Symfony\Component\HttpKernel\Log\DebugLoggerInterface;
class DebugHandler extends TestHandler implements DebugLoggerInterface
{
public function getLogs()
{
$records = array();
foreach ($this-&gt;records as $record) {
$records[] = array(&#039;timestamp&#039;=&gt; $record[&#039;datetime&#039;]-&gt;getTimestamp(),&#039;message&#039;=&gt; $record[&#039;message&#039;],&#039;priority&#039;=&gt; $record[&#039;level&#039;],&#039;priorityName&#039;=&gt; $record[&#039;level_name&#039;],&#039;context&#039;=&gt; $record[&#039;context&#039;],&#039;channel&#039;=&gt; isset($record[&#039;channel&#039;]) ? $record[&#039;channel&#039;] :&#039;&#039;,
);
}
return $records;
}
public function countErrors()
{
$cnt = 0;
$levels = array(Logger::ERROR, Logger::CRITICAL, Logger::ALERT, Logger::EMERGENCY);
foreach ($levels as $level) {
if (isset($this-&gt;recordsByLevel[$level])) {
$cnt += count($this-&gt;recordsByLevel[$level]);
}
}
return $cnt;
}
}
}
namespace Monolog\Handler\FingersCrossed
{
interface ActivationStrategyInterface
{
public function isHandlerActivated(array $record);
}
}
namespace Monolog\Handler\FingersCrossed
{
use Monolog\Logger;
class ErrorLevelActivationStrategy implements ActivationStrategyInterface
{
private $actionLevel;
public function __construct($actionLevel)
{
$this-&gt;actionLevel = Logger::toMonologLevel($actionLevel);
}
public function isHandlerActivated(array $record)
{
return $record[&#039;level&#039;] &gt;= $this-&gt;actionLevel;
}
}
}
namespace Doctrine\Common\Lexer
{
abstract class AbstractLexer
{
private $input;
private $tokens = array();
private $position = 0;
private $peek = 0;
public $lookahead;
public $token;
public function setInput($input)
{
$this-&gt;input = $input;
$this-&gt;tokens = array();
$this-&gt;reset();
$this-&gt;scan($input);
}
public function reset()
{
$this-&gt;lookahead = null;
$this-&gt;token = null;
$this-&gt;peek = 0;
$this-&gt;position = 0;
}
public function resetPeek()
{
$this-&gt;peek = 0;
}
public function resetPosition($position = 0)
{
$this-&gt;position = $position;
}
public function getInputUntilPosition($position)
{
return substr($this-&gt;input, 0, $position);
}
public function isNextToken($token)
{
return null !== $this-&gt;lookahead &amp;&amp; $this-&gt;lookahead[&#039;type&#039;] === $token;
}
public function isNextTokenAny(array $tokens)
{
return null !== $this-&gt;lookahead &amp;&amp; in_array($this-&gt;lookahead[&#039;type&#039;], $tokens, true);
}
public function moveNext()
{
$this-&gt;peek = 0;
$this-&gt;token = $this-&gt;lookahead;
$this-&gt;lookahead = (isset($this-&gt;tokens[$this-&gt;position]))
? $this-&gt;tokens[$this-&gt;position++] : null;
return $this-&gt;lookahead !== null;
}
public function skipUntil($type)
{
while ($this-&gt;lookahead !== null &amp;&amp; $this-&gt;lookahead[&#039;type&#039;] !== $type) {
$this-&gt;moveNext();
}
}
public function isA($value, $token)
{
return $this-&gt;getType($value) === $token;
}
public function peek()
{
if (isset($this-&gt;tokens[$this-&gt;position + $this-&gt;peek])) {
return $this-&gt;tokens[$this-&gt;position + $this-&gt;peek++];
} else {
return null;
}
}
public function glimpse()
{
$peek = $this-&gt;peek();
$this-&gt;peek = 0;
return $peek;
}
protected function scan($input)
{
static $regex;
if ( ! isset($regex)) {
$regex = sprintf(&#039;/(%s)|%s/%s&#039;,
implode(&#039;)|(&#039;, $this-&gt;getCatchablePatterns()),
implode(&#039;|&#039;, $this-&gt;getNonCatchablePatterns()),
$this-&gt;getModifiers()
);
}
$flags = PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_OFFSET_CAPTURE;
$matches = preg_split($regex, $input, -1, $flags);
foreach ($matches as $match) {
$type = $this-&gt;getType($match[0]);
$this-&gt;tokens[] = array(&#039;value&#039;=&gt; $match[0],&#039;type&#039;=&gt; $type,&#039;position&#039;=&gt; $match[1],
);
}
}
public function getLiteral($token)
{
$className = get_class($this);
$reflClass = new \ReflectionClass($className);
$constants = $reflClass-&gt;getConstants();
foreach ($constants as $name =&gt; $value) {
if ($value === $token) {
return $className .&#039;::&#039;. $name;
}
}
return $token;
}
protected function getModifiers()
{
return&#039;i&#039;;
}
abstract protected function getCatchablePatterns();
abstract protected function getNonCatchablePatterns();
abstract protected function getType(&amp;$value);
}
}
namespace Doctrine\Common\Annotations
{
use Doctrine\Common\Lexer\AbstractLexer;
final class DocLexer extends AbstractLexer
{
const T_NONE = 1;
const T_INTEGER = 2;
const T_STRING = 3;
const T_FLOAT = 4;
const T_IDENTIFIER = 100;
const T_AT = 101;
const T_CLOSE_CURLY_BRACES = 102;
const T_CLOSE_PARENTHESIS = 103;
const T_COMMA = 104;
const T_EQUALS = 105;
const T_FALSE = 106;
const T_NAMESPACE_SEPARATOR = 107;
const T_OPEN_CURLY_BRACES = 108;
const T_OPEN_PARENTHESIS = 109;
const T_TRUE = 110;
const T_NULL = 111;
const T_COLON = 112;
protected $noCase = array(&#039;@&#039;=&gt; self::T_AT,&#039;,&#039;=&gt; self::T_COMMA,&#039;(&#039;=&gt; self::T_OPEN_PARENTHESIS,&#039;)&#039;=&gt; self::T_CLOSE_PARENTHESIS,&#039;{&#039;=&gt; self::T_OPEN_CURLY_BRACES,&#039;}&#039;=&gt; self::T_CLOSE_CURLY_BRACES,&#039;=&#039;=&gt; self::T_EQUALS,&#039;:&#039;=&gt; self::T_COLON,&#039;\\&#039;=&gt; self::T_NAMESPACE_SEPARATOR
);
protected $withCase = array(&#039;true&#039;=&gt; self::T_TRUE,&#039;false&#039;=&gt; self::T_FALSE,&#039;null&#039;=&gt; self::T_NULL
);
protected function getCatchablePatterns()
{
return array(&#039;[a-z_\\\][a-z0-9_\:\\\]*[a-z_][a-z0-9_]*&#039;,&#039;(?:[+-]?[0-9]+(?:[\.][0-9]+)*)(?:[eE][+-]?[0-9]+)?&#039;,&#039;&quot;(?:&quot;&quot;|[^&quot;])*+&quot;&#039;,
);
}
protected function getNonCatchablePatterns()
{
return array(&#039;\s+&#039;,&#039;\*+&#039;,&#039;(.)&#039;);
}
protected function getType(&amp;$value)
{
$type = self::T_NONE;
if ($value[0] ===&#039;&quot;&#039;) {
$value = str_replace(&#039;&quot;&quot;&#039;,&#039;&quot;&#039;, substr($value, 1, strlen($value) - 2));
return self::T_STRING;
}
if (isset($this-&gt;noCase[$value])) {
return $this-&gt;noCase[$value];
}
if ($value[0] ===&#039;_&#039;|| $value[0] ===&#039;\\&#039;|| ctype_alpha($value[0])) {
return self::T_IDENTIFIER;
}
$lowerValue = strtolower($value);
if (isset($this-&gt;withCase[$lowerValue])) {
return $this-&gt;withCase[$lowerValue];
}
if (is_numeric($value)) {
return (strpos($value,&#039;.&#039;) !== false || stripos($value,&#039;e&#039;) !== false)
? self::T_FLOAT : self::T_INTEGER;
}
return $type;
}
}
}
namespace Doctrine\Common\Annotations
{
interface Reader
{
function getClassAnnotations(\ReflectionClass $class);
function getClassAnnotation(\ReflectionClass $class, $annotationName);
function getMethodAnnotations(\ReflectionMethod $method);
function getMethodAnnotation(\ReflectionMethod $method, $annotationName);
function getPropertyAnnotations(\ReflectionProperty $property);
function getPropertyAnnotation(\ReflectionProperty $property, $annotationName);
}
}
namespace Doctrine\Common\Annotations
{
class FileCacheReader implements Reader
{
private $reader;
private $dir;
private $debug;
private $loadedAnnotations = array();
private $classNameHashes = array();
private $umask;
public function __construct(Reader $reader, $cacheDir, $debug = false, $umask = 0002)
{
if ( ! is_int($umask)) {
throw new \InvalidArgumentException(sprintf(&#039;The parameter umask must be an integer, was: %s&#039;,
gettype($umask)
));
}
$this-&gt;reader = $reader;
$this-&gt;umask = $umask;
if (!is_dir($cacheDir) &amp;&amp; !@mkdir($cacheDir, 0777 &amp; (~$this-&gt;umask), true)) {
throw new \InvalidArgumentException(sprintf(&#039;The directory &quot;%s&quot; does not exist and could not be created.&#039;, $cacheDir));
}
$this-&gt;dir = rtrim($cacheDir,&#039;\\/&#039;);
$this-&gt;debug = $debug;
}
public function getClassAnnotations(\ReflectionClass $class)
{
if ( ! isset($this-&gt;classNameHashes[$class-&gt;name])) {
$this-&gt;classNameHashes[$class-&gt;name] = sha1($class-&gt;name);
}
$key = $this-&gt;classNameHashes[$class-&gt;name];
if (isset($this-&gt;loadedAnnotations[$key])) {
return $this-&gt;loadedAnnotations[$key];
}
$path = $this-&gt;dir.&#039;/&#039;.strtr($key,&#039;\\&#039;,&#039;-&#039;).&#039;.cache.php&#039;;
if (!is_file($path)) {
$annot = $this-&gt;reader-&gt;getClassAnnotations($class);
$this-&gt;saveCacheFile($path, $annot);
return $this-&gt;loadedAnnotations[$key] = $annot;
}
if ($this-&gt;debug
&amp;&amp; (false !== $filename = $class-&gt;getFilename())
&amp;&amp; filemtime($path) &lt; filemtime($filename)) {
@unlink($path);
$annot = $this-&gt;reader-&gt;getClassAnnotations($class);
$this-&gt;saveCacheFile($path, $annot);
return $this-&gt;loadedAnnotations[$key] = $annot;
}
return $this-&gt;loadedAnnotations[$key] = include $path;
}
public function getPropertyAnnotations(\ReflectionProperty $property)
{
$class = $property-&gt;getDeclaringClass();
if ( ! isset($this-&gt;classNameHashes[$class-&gt;name])) {
$this-&gt;classNameHashes[$class-&gt;name] = sha1($class-&gt;name);
}
$key = $this-&gt;classNameHashes[$class-&gt;name].&#039;$&#039;.$property-&gt;getName();
if (isset($this-&gt;loadedAnnotations[$key])) {
return $this-&gt;loadedAnnotations[$key];
}
$path = $this-&gt;dir.&#039;/&#039;.strtr($key,&#039;\\&#039;,&#039;-&#039;).&#039;.cache.php&#039;;
if (!is_file($path)) {
$annot = $this-&gt;reader-&gt;getPropertyAnnotations($property);
$this-&gt;saveCacheFile($path, $annot);
return $this-&gt;loadedAnnotations[$key] = $annot;
}
if ($this-&gt;debug
&amp;&amp; (false !== $filename = $class-&gt;getFilename())
&amp;&amp; filemtime($path) &lt; filemtime($filename)) {
@unlink($path);
$annot = $this-&gt;reader-&gt;getPropertyAnnotations($property);
$this-&gt;saveCacheFile($path, $annot);
return $this-&gt;loadedAnnotations[$key] = $annot;
}
return $this-&gt;loadedAnnotations[$key] = include $path;
}
public function getMethodAnnotations(\ReflectionMethod $method)
{
$class = $method-&gt;getDeclaringClass();
if ( ! isset($this-&gt;classNameHashes[$class-&gt;name])) {
$this-&gt;classNameHashes[$class-&gt;name] = sha1($class-&gt;name);
}
$key = $this-&gt;classNameHashes[$class-&gt;name].&#039;#&#039;.$method-&gt;getName();
if (isset($this-&gt;loadedAnnotations[$key])) {
return $this-&gt;loadedAnnotations[$key];
}
$path = $this-&gt;dir.&#039;/&#039;.strtr($key,&#039;\\&#039;,&#039;-&#039;).&#039;.cache.php&#039;;
if (!is_file($path)) {
$annot = $this-&gt;reader-&gt;getMethodAnnotations($method);
$this-&gt;saveCacheFile($path, $annot);
return $this-&gt;loadedAnnotations[$key] = $annot;
}
if ($this-&gt;debug
&amp;&amp; (false !== $filename = $class-&gt;getFilename())
&amp;&amp; filemtime($path) &lt; filemtime($filename)) {
@unlink($path);
$annot = $this-&gt;reader-&gt;getMethodAnnotations($method);
$this-&gt;saveCacheFile($path, $annot);
return $this-&gt;loadedAnnotations[$key] = $annot;
}
return $this-&gt;loadedAnnotations[$key] = include $path;
}
private function saveCacheFile($path, $data)
{
if (!is_writable($this-&gt;dir)) {
throw new \InvalidArgumentException(sprintf(&#039;The directory &quot;%s&quot; is not writable. Both, the webserver and the console user need access. You can manage access rights for multiple users with &quot;chmod +a&quot;. If your system does not support this, check out the acl package.&#039;, $this-&gt;dir));
}
$tempfile = tempnam($this-&gt;dir, uniqid(&#039;&#039;, true));
if (false === $tempfile) {
throw new \RuntimeException(sprintf(&#039;Unable to create tempfile in directory: %s&#039;, $this-&gt;dir));
}
$written = file_put_contents($tempfile,&#039;&lt;?php return unserialize(&#039;.var_export(serialize($data), true).&#039;);&#039;);
if (false === $written) {
throw new \RuntimeException(sprintf(&#039;Unable to write cached file to: %s&#039;, $tempfile));
}
@chmod($tempfile, 0666 &amp; (~$this-&gt;umask));
if (false === rename($tempfile, $path)) {
@unlink($tempfile);
throw new \RuntimeException(sprintf(&#039;Unable to rename %s to %s&#039;, $tempfile, $path));
}
}
public function getClassAnnotation(\ReflectionClass $class, $annotationName)
{
$annotations = $this-&gt;getClassAnnotations($class);
foreach ($annotations as $annotation) {
if ($annotation instanceof $annotationName) {
return $annotation;
}
}
return null;
}
public function getMethodAnnotation(\ReflectionMethod $method, $annotationName)
{
$annotations = $this-&gt;getMethodAnnotations($method);
foreach ($annotations as $annotation) {
if ($annotation instanceof $annotationName) {
return $annotation;
}
}
return null;
}
public function getPropertyAnnotation(\ReflectionProperty $property, $annotationName)
{
$annotations = $this-&gt;getPropertyAnnotations($property);
foreach ($annotations as $annotation) {
if ($annotation instanceof $annotationName) {
return $annotation;
}
}
return null;
}
public function clearLoadedAnnotations()
{
$this-&gt;loadedAnnotations = array();
}
}
}
namespace Doctrine\Common\Annotations
{
use SplFileObject;
final class PhpParser
{
public function parseClass(\ReflectionClass $class)
{
if (method_exists($class,&#039;getUseStatements&#039;)) {
return $class-&gt;getUseStatements();
}
if (false === $filename = $class-&gt;getFilename()) {
return array();
}
$content = $this-&gt;getFileContent($filename, $class-&gt;getStartLine());
if (null === $content) {
return array();
}
$namespace = preg_quote($class-&gt;getNamespaceName());
$content = preg_replace(&#039;/^.*?(\bnamespace\s+&#039;. $namespace .&#039;\s*[;{].*)$/s&#039;,&#039;\\1&#039;, $content);
$tokenizer = new TokenParser(&#039;&lt;?php &#039;. $content);
$statements = $tokenizer-&gt;parseUseStatements($class-&gt;getNamespaceName());
return $statements;
}
private function getFileContent($filename, $lineNumber)
{
if ( ! is_file($filename)) {
return null;
}
$content =&#039;&#039;;
$lineCnt = 0;
$file = new SplFileObject($filename);
while (!$file-&gt;eof()) {
if ($lineCnt++ == $lineNumber) {
break;
}
$content .= $file-&gt;fgets();
}
return $content;
}
}
}
namespace Doctrine\Common
{
use Doctrine\Common\Lexer\AbstractLexer;
abstract class Lexer extends AbstractLexer
{
}
}
namespace Doctrine\Common\Persistence
{
interface ConnectionRegistry
{
public function getDefaultConnectionName();
public function getConnection($name = null);
public function getConnections();
public function getConnectionNames();
}
}
namespace Doctrine\Common\Persistence
{
interface Proxy
{
const MARKER =&#039;__CG__&#039;;
const MARKER_LENGTH = 6;
public function __load();
public function __isInitialized();
}
}
namespace Doctrine\Common\Util
{
use Doctrine\Common\Persistence\Proxy;
class ClassUtils
{
public static function getRealClass($class)
{
if (false === $pos = strrpos($class,&#039;\\&#039;.Proxy::MARKER.&#039;\\&#039;)) {
return $class;
}
return substr($class, $pos + Proxy::MARKER_LENGTH + 2);
}
public static function getClass($object)
{
return self::getRealClass(get_class($object));
}
public static function getParentClass($className)
{
return get_parent_class( self::getRealClass( $className ) );
}
public static function newReflectionClass($class)
{
return new \ReflectionClass( self::getRealClass( $class ) );
}
public static function newReflectionObject($object)
{
return self::newReflectionClass( self::getClass( $object ) );
}
public static function generateProxyClassName($className, $proxyNamespace)
{
return rtrim($proxyNamespace,&#039;\\&#039;) .&#039;\\&#039;.Proxy::MARKER.&#039;\\&#039;. ltrim($className,&#039;\\&#039;);
}
}
}
namespace Symfony\Component\DependencyInjection
{
interface ContainerAwareInterface
{
public function setContainer(ContainerInterface $container = null);
}
}
namespace Doctrine\Common\Persistence
{
interface ManagerRegistry extends ConnectionRegistry
{
public function getDefaultManagerName();
public function getManager($name = null);
public function getManagers();
public function resetManager($name = null);
public function getAliasNamespace($alias);
public function getManagerNames();
public function getRepository($persistentObject, $persistentManagerName = null);
public function getManagerForClass($class);
}
}
namespace Symfony\Bridge\Doctrine
{
use Doctrine\Common\Persistence\ManagerRegistry as ManagerRegistryInterface;
use Doctrine\ORM\EntityManager;
interface RegistryInterface extends ManagerRegistryInterface
{
public function getDefaultEntityManagerName();
public function getEntityManager($name = null);
public function getEntityManagers();
public function resetEntityManager($name = null);
public function getEntityNamespace($alias);
public function getEntityManagerNames();
public function getEntityManagerForClass($class);
}
}
namespace Doctrine\Common\Persistence
{
abstract class AbstractManagerRegistry implements ManagerRegistry
{
private $name;
private $connections;
private $managers;
private $defaultConnection;
private $defaultManager;
private $proxyInterfaceName;
public function __construct($name, array $connections, array $managers, $defaultConnection, $defaultManager, $proxyInterfaceName)
{
$this-&gt;name = $name;
$this-&gt;connections = $connections;
$this-&gt;managers = $managers;
$this-&gt;defaultConnection = $defaultConnection;
$this-&gt;defaultManager = $defaultManager;
$this-&gt;proxyInterfaceName = $proxyInterfaceName;
}
abstract protected function getService($name);
abstract protected function resetService($name);
public function getName()
{
return $this-&gt;name;
}
public function getConnection($name = null)
{
if (null === $name) {
$name = $this-&gt;defaultConnection;
}
if (!isset($this-&gt;connections[$name])) {
throw new \InvalidArgumentException(sprintf(&#039;Doctrine %s Connection named &quot;%s&quot; does not exist.&#039;, $this-&gt;name, $name));
}
return $this-&gt;getService($this-&gt;connections[$name]);
}
public function getConnectionNames()
{
return $this-&gt;connections;
}
public function getConnections()
{
$connections = [];
foreach ($this-&gt;connections as $name =&gt; $id) {
$connections[$name] = $this-&gt;getService($id);
}
return $connections;
}
public function getDefaultConnectionName()
{
return $this-&gt;defaultConnection;
}
public function getDefaultManagerName()
{
return $this-&gt;defaultManager;
}
public function getManager($name = null)
{
if (null === $name) {
$name = $this-&gt;defaultManager;
}
if (!isset($this-&gt;managers[$name])) {
throw new \InvalidArgumentException(sprintf(&#039;Doctrine %s Manager named &quot;%s&quot; does not exist.&#039;, $this-&gt;name, $name));
}
return $this-&gt;getService($this-&gt;managers[$name]);
}
public function getManagerForClass($class)
{
if (strpos($class,&#039;:&#039;) !== false) {
list($namespaceAlias, $simpleClassName) = explode(&#039;:&#039;, $class, 2);
$class = $this-&gt;getAliasNamespace($namespaceAlias) .&#039;\\&#039;. $simpleClassName;
}
$proxyClass = new \ReflectionClass($class);
if ($proxyClass-&gt;implementsInterface($this-&gt;proxyInterfaceName)) {
if (! $parentClass = $proxyClass-&gt;getParentClass()) {
return null;
}
$class = $parentClass-&gt;getName();
}
foreach ($this-&gt;managers as $id) {
$manager = $this-&gt;getService($id);
if (!$manager-&gt;getMetadataFactory()-&gt;isTransient($class)) {
return $manager;
}
}
}
public function getManagerNames()
{
return $this-&gt;managers;
}
public function getManagers()
{
$dms = [];
foreach ($this-&gt;managers as $name =&gt; $id) {
$dms[$name] = $this-&gt;getService($id);
}
return $dms;
}
public function getRepository($persistentObjectName, $persistentManagerName = null)
{
return $this-&gt;getManager($persistentManagerName)-&gt;getRepository($persistentObjectName);
}
public function resetManager($name = null)
{
if (null === $name) {
$name = $this-&gt;defaultManager;
}
if (!isset($this-&gt;managers[$name])) {
throw new \InvalidArgumentException(sprintf(&#039;Doctrine %s Manager named &quot;%s&quot; does not exist.&#039;, $this-&gt;name, $name));
}
$this-&gt;resetService($this-&gt;managers[$name]);
}
}
}
namespace Symfony\Bridge\Doctrine
{
use Symfony\Component\DependencyInjection\ContainerAwareInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Doctrine\Common\Persistence\AbstractManagerRegistry;
abstract class ManagerRegistry extends AbstractManagerRegistry implements ContainerAwareInterface
{
protected $container;
protected function getService($name)
{
return $this-&gt;container-&gt;get($name);
}
protected function resetService($name)
{
$this-&gt;container-&gt;set($name, null);
}
public function setContainer(ContainerInterface $container = null)
{
$this-&gt;container = $container;
}
}
}
namespace Doctrine\Bundle\DoctrineBundle
{
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Bridge\Doctrine\RegistryInterface;
use Symfony\Bridge\Doctrine\ManagerRegistry;
use Doctrine\ORM\ORMException;
use Doctrine\ORM\EntityManager;
class Registry extends ManagerRegistry implements RegistryInterface
{
public function __construct(ContainerInterface $container, array $connections, array $entityManagers, $defaultConnection, $defaultEntityManager)
{
$this-&gt;setContainer($container);
parent::__construct(&#039;ORM&#039;, $connections, $entityManagers, $defaultConnection, $defaultEntityManager,&#039;Doctrine\ORM\Proxy\Proxy&#039;);
}
public function getDefaultEntityManagerName()
{
trigger_error(&#039;getDefaultEntityManagerName is deprecated since Symfony 2.1. Use getDefaultManagerName instead&#039;, E_USER_DEPRECATED);
return $this-&gt;getDefaultManagerName();
}
public function getEntityManager($name = null)
{
trigger_error(&#039;getEntityManager is deprecated since Symfony 2.1. Use getManager instead&#039;, E_USER_DEPRECATED);
return $this-&gt;getManager($name);
}
public function getEntityManagers()
{
trigger_error(&#039;getEntityManagers is deprecated since Symfony 2.1. Use getManagers instead&#039;, E_USER_DEPRECATED);
return $this-&gt;getManagers();
}
public function resetEntityManager($name = null)
{
trigger_error(&#039;resetEntityManager is deprecated since Symfony 2.1. Use resetManager instead&#039;, E_USER_DEPRECATED);
$this-&gt;resetManager($name);
}
public function getEntityNamespace($alias)
{
trigger_error(&#039;getEntityNamespace is deprecated since Symfony 2.1. Use getAliasNamespace instead&#039;, E_USER_DEPRECATED);
return $this-&gt;getAliasNamespace($alias);
}
public function getAliasNamespace($alias)
{
foreach (array_keys($this-&gt;getManagers()) as $name) {
try {
return $this-&gt;getManager($name)-&gt;getConfiguration()-&gt;getEntityNamespace($alias);
} catch (ORMException $e) {
}
}
throw ORMException::unknownEntityNamespace($alias);
}
public function getEntityManagerNames()
{
trigger_error(&#039;getEntityManagerNames is deprecated since Symfony 2.1. Use getManagerNames instead&#039;, E_USER_DEPRECATED);
return $this-&gt;getManagerNames();
}
public function getEntityManagerForClass($class)
{
trigger_error(&#039;getEntityManagerForClass is deprecated since Symfony 2.1. Use getManagerForClass instead&#039;, E_USER_DEPRECATED);
return $this-&gt;getManagerForClass($class);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Doctrine\Common\Annotations\Reader;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationInterface;
use Doctrine\Common\Util\ClassUtils;
class ControllerListener implements EventSubscriberInterface
{
protected $reader;
public function __construct(Reader $reader)
{
$this-&gt;reader = $reader;
}
public function onKernelController(FilterControllerEvent $event)
{
if (!is_array($controller = $event-&gt;getController())) {
return;
}
$className = class_exists(&#039;Doctrine\Common\Util\ClassUtils&#039;) ? ClassUtils::getClass($controller[0]) : get_class($controller[0]);
$object = new \ReflectionClass($className);
$method = $object-&gt;getMethod($controller[1]);
$classConfigurations = $this-&gt;getConfigurations($this-&gt;reader-&gt;getClassAnnotations($object));
$methodConfigurations = $this-&gt;getConfigurations($this-&gt;reader-&gt;getMethodAnnotations($method));
$configurations = array();
foreach (array_merge(array_keys($classConfigurations), array_keys($methodConfigurations)) as $key) {
if (!array_key_exists($key, $classConfigurations)) {
$configurations[$key] = $methodConfigurations[$key];
} elseif (!array_key_exists($key, $methodConfigurations)) {
$configurations[$key] = $classConfigurations[$key];
} else {
if (is_array($classConfigurations[$key])) {
if (!is_array($methodConfigurations[$key])) {
throw new \UnexpectedValueException(&#039;Configurations should both be an array or both not be an array&#039;);
}
$configurations[$key] = array_merge($classConfigurations[$key], $methodConfigurations[$key]);
} else {
$configurations[$key] = $methodConfigurations[$key];
}
}
}
$request = $event-&gt;getRequest();
foreach ($configurations as $key =&gt; $attributes) {
$request-&gt;attributes-&gt;set($key, $attributes);
}
}
protected function getConfigurations(array $annotations)
{
$configurations = array();
foreach ($annotations as $configuration) {
if ($configuration instanceof ConfigurationInterface) {
if ($configuration-&gt;allowArray()) {
$configurations[&#039;_&#039;.$configuration-&gt;getAliasName()][] = $configuration;
} elseif (!isset($configurations[&#039;_&#039;.$configuration-&gt;getAliasName()])) {
$configurations[&#039;_&#039;.$configuration-&gt;getAliasName()] = $configuration;
} else {
throw new \LogicException(sprintf(&#039;Multiple &quot;%s&quot; annotations are not allowed.&#039;, $configuration-&gt;getAliasName()));
}
}
}
return $configurations;
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::CONTROLLER =&gt;&#039;onKernelController&#039;,
);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterManager;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class ParamConverterListener implements EventSubscriberInterface
{
protected $manager;
protected $autoConvert;
public function __construct(ParamConverterManager $manager, $autoConvert = true)
{
$this-&gt;manager = $manager;
$this-&gt;autoConvert = $autoConvert;
}
public function onKernelController(FilterControllerEvent $event)
{
$controller = $event-&gt;getController();
$request = $event-&gt;getRequest();
$configurations = array();
if ($configuration = $request-&gt;attributes-&gt;get(&#039;_converters&#039;)) {
foreach (is_array($configuration) ? $configuration : array($configuration) as $configuration) {
$configurations[$configuration-&gt;getName()] = $configuration;
}
}
if (is_array($controller)) {
$r = new \ReflectionMethod($controller[0], $controller[1]);
} elseif (is_object($controller) &amp;&amp; is_callable($controller,&#039;__invoke&#039;)) {
$r = new \ReflectionMethod($controller,&#039;__invoke&#039;);
} else {
$r = new \ReflectionFunction($controller);
}
if ($this-&gt;autoConvert) {
$configurations = $this-&gt;autoConfigure($r, $request, $configurations);
}
$this-&gt;manager-&gt;apply($request, $configurations);
}
private function autoConfigure(\ReflectionFunctionAbstract $r, Request $request, $configurations)
{
foreach ($r-&gt;getParameters() as $param) {
if (!$param-&gt;getClass() || $param-&gt;getClass()-&gt;isInstance($request)) {
continue;
}
$name = $param-&gt;getName();
if (!isset($configurations[$name])) {
$configuration = new ParamConverter(array());
$configuration-&gt;setName($name);
$configuration-&gt;setClass($param-&gt;getClass()-&gt;getName());
$configurations[$name] = $configuration;
} elseif (null === $configurations[$name]-&gt;getClass()) {
$configurations[$name]-&gt;setClass($param-&gt;getClass()-&gt;getName());
}
$configurations[$name]-&gt;setIsOptional($param-&gt;isOptional());
}
return $configurations;
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::CONTROLLER =&gt;&#039;onKernelController&#039;,
);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\HttpFoundation\Request;
interface ParamConverterInterface
{
public function apply(Request $request, ParamConverter $configuration);
public function supports(ParamConverter $configuration);
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use DateTime;
class DateTimeParamConverter implements ParamConverterInterface
{
public function apply(Request $request, ParamConverter $configuration)
{
$param = $configuration-&gt;getName();
if (!$request-&gt;attributes-&gt;has($param)) {
return false;
}
$options = $configuration-&gt;getOptions();
$value = $request-&gt;attributes-&gt;get($param);
if (!$value &amp;&amp; $configuration-&gt;isOptional()) {
return false;
}
if (isset($options[&#039;format&#039;])) {
$date = DateTime::createFromFormat($options[&#039;format&#039;], $value);
if (!$date) {
throw new NotFoundHttpException(&#039;Invalid date given.&#039;);
}
} else {
if (false === strtotime($value)) {
throw new NotFoundHttpException(&#039;Invalid date given.&#039;);
}
$date = new DateTime($value);
}
$request-&gt;attributes-&gt;set($param, $date);
return true;
}
public function supports(ParamConverter $configuration)
{
if (null === $configuration-&gt;getClass()) {
return false;
}
return&#039;DateTime&#039;=== $configuration-&gt;getClass();
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpFoundation\Request;
use Doctrine\Common\Persistence\ManagerRegistry;
use Doctrine\ORM\NoResultException;
class DoctrineParamConverter implements ParamConverterInterface
{
protected $registry;
public function __construct(ManagerRegistry $registry = null)
{
$this-&gt;registry = $registry;
}
public function apply(Request $request, ParamConverter $configuration)
{
$name = $configuration-&gt;getName();
$class = $configuration-&gt;getClass();
$options = $this-&gt;getOptions($configuration);
if (null === $request-&gt;attributes-&gt;get($name, false)) {
$configuration-&gt;setIsOptional(true);
}
if (false === $object = $this-&gt;find($class, $request, $options, $name)) {
if (false === $object = $this-&gt;findOneBy($class, $request, $options)) {
if ($configuration-&gt;isOptional()) {
$object = null;
} else {
throw new \LogicException(&#039;Unable to guess how to get a Doctrine instance from the request information.&#039;);
}
}
}
if (null === $object &amp;&amp; false === $configuration-&gt;isOptional()) {
throw new NotFoundHttpException(sprintf(&#039;%s object not found.&#039;, $class));
}
$request-&gt;attributes-&gt;set($name, $object);
return true;
}
protected function find($class, Request $request, $options, $name)
{
if ($options[&#039;mapping&#039;] || $options[&#039;exclude&#039;]) {
return false;
}
$id = $this-&gt;getIdentifier($request, $options, $name);
if (false === $id || null === $id) {
return false;
}
if (isset($options[&#039;repository_method&#039;])) {
$method = $options[&#039;repository_method&#039;];
} else {
$method =&#039;find&#039;;
}
try {
return $this-&gt;getManager($options[&#039;entity_manager&#039;], $class)-&gt;getRepository($class)-&gt;$method($id);
} catch (NoResultException $e) {
return;
}
}
protected function getIdentifier(Request $request, $options, $name)
{
if (isset($options[&#039;id&#039;])) {
if (!is_array($options[&#039;id&#039;])) {
$name = $options[&#039;id&#039;];
} elseif (is_array($options[&#039;id&#039;])) {
$id = array();
foreach ($options[&#039;id&#039;] as $field) {
$id[$field] = $request-&gt;attributes-&gt;get($field);
}
return $id;
}
}
if ($request-&gt;attributes-&gt;has($name)) {
return $request-&gt;attributes-&gt;get($name);
}
if ($request-&gt;attributes-&gt;has(&#039;id&#039;) &amp;&amp; !isset($options[&#039;id&#039;])) {
return $request-&gt;attributes-&gt;get(&#039;id&#039;);
}
return false;
}
protected function findOneBy($class, Request $request, $options)
{
if (!$options[&#039;mapping&#039;]) {
$keys = $request-&gt;attributes-&gt;keys();
$options[&#039;mapping&#039;] = $keys ? array_combine($keys, $keys) : array();
}
foreach ($options[&#039;exclude&#039;] as $exclude) {
unset($options[&#039;mapping&#039;][$exclude]);
}
if (!$options[&#039;mapping&#039;]) {
return false;
}
if (isset($options[&#039;id&#039;]) &amp;&amp; null === $request-&gt;attributes-&gt;get($options[&#039;id&#039;])) {
return false;
}
$criteria = array();
$em = $this-&gt;getManager($options[&#039;entity_manager&#039;], $class);
$metadata = $em-&gt;getClassMetadata($class);
$mapMethodSignature = isset($options[&#039;repository_method&#039;])
&amp;&amp; isset($options[&#039;map_method_signature&#039;])
&amp;&amp; $options[&#039;map_method_signature&#039;] === true;
foreach ($options[&#039;mapping&#039;] as $attribute =&gt; $field) {
if ($metadata-&gt;hasField($field)
|| ($metadata-&gt;hasAssociation($field) &amp;&amp; $metadata-&gt;isSingleValuedAssociation($field))
|| $mapMethodSignature) {
$criteria[$field] = $request-&gt;attributes-&gt;get($attribute);
}
}
if ($options[&#039;strip_null&#039;]) {
$criteria = array_filter($criteria, function ($value) { return !is_null($value); });
}
if (!$criteria) {
return false;
}
if (isset($options[&#039;repository_method&#039;])) {
$repositoryMethod = $options[&#039;repository_method&#039;];
} else {
$repositoryMethod =&#039;findOneBy&#039;;
}
try {
if ($mapMethodSignature) {
return $this-&gt;findDataByMapMethodSignature($em, $class, $repositoryMethod, $criteria);
}
return $em-&gt;getRepository($class)-&gt;$repositoryMethod($criteria);
} catch (NoResultException $e) {
return;
}
}
private function findDataByMapMethodSignature($em, $class, $repositoryMethod, $criteria)
{
$arguments = array();
$repository = $em-&gt;getRepository($class);
$ref = new \ReflectionMethod($repository, $repositoryMethod);
foreach ($ref-&gt;getParameters() as $parameter) {
if (array_key_exists($parameter-&gt;name, $criteria)) {
$arguments[] = $criteria[$parameter-&gt;name];
} elseif ($parameter-&gt;isDefaultValueAvailable()) {
$arguments[] = $parameter-&gt;getDefaultValue();
} else {
throw new \InvalidArgumentException(sprintf(&#039;Repository method &quot;%s::%s&quot; requires that you provide a value for the &quot;$%s&quot; argument.&#039;, get_class($repository), $repositoryMethod, $parameter-&gt;name));
}
}
return $ref-&gt;invokeArgs($repository, $arguments);
}
public function supports(ParamConverter $configuration)
{
if (null === $this-&gt;registry || !count($this-&gt;registry-&gt;getManagers())) {
return false;
}
if (null === $configuration-&gt;getClass()) {
return false;
}
$options = $this-&gt;getOptions($configuration);
$em = $this-&gt;getManager($options[&#039;entity_manager&#039;], $configuration-&gt;getClass());
if (null === $em) {
return false;
}
return !$em-&gt;getMetadataFactory()-&gt;isTransient($configuration-&gt;getClass());
}
protected function getOptions(ParamConverter $configuration)
{
return array_replace(array(&#039;entity_manager&#039;=&gt; null,&#039;exclude&#039;=&gt; array(),&#039;mapping&#039;=&gt; array(),&#039;strip_null&#039;=&gt; false,
), $configuration-&gt;getOptions());
}
private function getManager($name, $class)
{
if (null === $name) {
return $this-&gt;registry-&gt;getManagerForClass($class);
}
return $this-&gt;registry-&gt;getManager($name);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Symfony\Component\HttpFoundation\Request;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationInterface;
class ParamConverterManager
{
protected $converters = array();
protected $namedConverters = array();
public function apply(Request $request, $configurations)
{
if (is_object($configurations)) {
$configurations = array($configurations);
}
foreach ($configurations as $configuration) {
$this-&gt;applyConverter($request, $configuration);
}
}
protected function applyConverter(Request $request, ConfigurationInterface $configuration)
{
$value = $request-&gt;attributes-&gt;get($configuration-&gt;getName());
$className = $configuration-&gt;getClass();
if (is_object($value) &amp;&amp; $value instanceof $className) {
return;
}
if ($converterName = $configuration-&gt;getConverter()) {
if (!isset($this-&gt;namedConverters[$converterName])) {
throw new \RuntimeException(sprintf(&quot;No converter named &#039;%s&#039; found for conversion of parameter &#039;%s&#039;.&quot;,
$converterName, $configuration-&gt;getName()
));
}
$converter = $this-&gt;namedConverters[$converterName];
if (!$converter-&gt;supports($configuration)) {
throw new \RuntimeException(sprintf(&quot;Converter &#039;%s&#039; does not support conversion of parameter &#039;%s&#039;.&quot;,
$converterName, $configuration-&gt;getName()
));
}
$converter-&gt;apply($request, $configuration);
return;
}
foreach ($this-&gt;all() as $converter) {
if ($converter-&gt;supports($configuration)) {
if ($converter-&gt;apply($request, $configuration)) {
return;
}
}
}
}
public function add(ParamConverterInterface $converter, $priority = 0, $name = null)
{
if ($priority !== null) {
if (!isset($this-&gt;converters[$priority])) {
$this-&gt;converters[$priority] = array();
}
$this-&gt;converters[$priority][] = $converter;
}
if (null !== $name) {
$this-&gt;namedConverters[$name] = $converter;
}
}
public function all()
{
krsort($this-&gt;converters);
$converters = array();
foreach ($this-&gt;converters as $all) {
$converters = array_merge($converters, $all);
}
return $converters;
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpFoundation\StreamedResponse;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;
class TemplateListener implements EventSubscriberInterface
{
protected $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function onKernelController(FilterControllerEvent $event)
{
$request = $event-&gt;getRequest();
$template = $request-&gt;attributes-&gt;get(&#039;_template&#039;);
if (null === $template) {
return;
}
if (!$template instanceof Template) {
throw new \InvalidArgumentException(&#039;Request attribute &quot;_template&quot; is reserved for @Template annotations.&#039;);
}
$template-&gt;setOwner($event-&gt;getController());
}
public function onKernelView(GetResponseForControllerResultEvent $event)
{
$request = $event-&gt;getRequest();
$template = $request-&gt;attributes-&gt;get(&#039;_template&#039;);
if (null === $template) {
return;
}
$parameters = $event-&gt;getControllerResult();
$owner = $template-&gt;getOwner();
list($controller, $action) = $owner;
if (null === $template-&gt;getTemplate()) {
if ($action ===&#039;__invoke&#039;) {
throw new \InvalidArgumentException(sprintf(&#039;Cannot guess a template name for &quot;%s::%s&quot;, please provide a template name.&#039;, get_class($controller), $action));
}
$guesser = $this-&gt;container-&gt;get(&#039;sensio_framework_extra.view.guesser&#039;);
$template-&gt;setTemplate($guesser-&gt;guessTemplateName($owner, $request, $template-&gt;getEngine()));
}
if (null === $parameters) {
$parameters = $this-&gt;resolveDefaultParameters($request, $template, $controller, $action);
}
$templating = $this-&gt;container-&gt;get(&#039;templating&#039;);
if ($template-&gt;isStreamable()) {
$callback = function () use ($templating, $template, $parameters) {
return $templating-&gt;stream($template-&gt;getTemplate(), $parameters);
};
$event-&gt;setResponse(new StreamedResponse($callback));
}
$template-&gt;setOwner(array());
$event-&gt;setResponse($templating-&gt;renderResponse($template-&gt;getTemplate(), $parameters));
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::CONTROLLER =&gt; array(&#039;onKernelController&#039;, -128),
KernelEvents::VIEW =&gt;&#039;onKernelView&#039;,
);
}
private function resolveDefaultParameters(Request $request, Template $template, $controller, $action)
{
$parameters = array();
$arguments = $template-&gt;getVars();
if (0 === count($arguments)) {
$r = new \ReflectionObject($controller);
$arguments = array();
foreach ($r-&gt;getMethod($action)-&gt;getParameters() as $param) {
$arguments[] = $param-&gt;getName();
}
}
foreach ($arguments as $argument) {
$parameters[$argument] = $request-&gt;attributes-&gt;get($argument);
}
return $parameters;
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\Event\FilterResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
class HttpCacheListener implements EventSubscriberInterface
{
private $lastModifiedDates;
private $etags;
private $expressionLanguage;
public function __construct()
{
$this-&gt;lastModifiedDates = new \SplObjectStorage();
$this-&gt;etags = new \SplObjectStorage();
}
public function onKernelController(FilterControllerEvent $event)
{
$request = $event-&gt;getRequest();
if (!$configuration = $request-&gt;attributes-&gt;get(&#039;_cache&#039;)) {
return;
}
$response = new Response();
$lastModifiedDate =&#039;&#039;;
if ($configuration-&gt;getLastModified()) {
$lastModifiedDate = $this-&gt;getExpressionLanguage()-&gt;evaluate($configuration-&gt;getLastModified(), $request-&gt;attributes-&gt;all());
$response-&gt;setLastModified($lastModifiedDate);
}
$etag =&#039;&#039;;
if ($configuration-&gt;getETag()) {
$etag = hash(&#039;sha256&#039;, $this-&gt;getExpressionLanguage()-&gt;evaluate($configuration-&gt;getETag(), $request-&gt;attributes-&gt;all()));
$response-&gt;setETag($etag);
}
if ($response-&gt;isNotModified($request)) {
$event-&gt;setController(function () use ($response) {
return $response;
});
} else {
if ($etag) {
$this-&gt;etags[$request] = $etag;
}
if ($lastModifiedDate) {
$this-&gt;lastModifiedDates[$request] = $lastModifiedDate;
}
}
}
public function onKernelResponse(FilterResponseEvent $event)
{
$request = $event-&gt;getRequest();
if (!$configuration = $request-&gt;attributes-&gt;get(&#039;_cache&#039;)) {
return;
}
$response = $event-&gt;getResponse();
if (!in_array($response-&gt;getStatusCode(), array(200, 203, 300, 301, 302, 304, 404, 410))) {
return;
}
if (null !== $age = $configuration-&gt;getSMaxAge()) {
if (!is_numeric($age)) {
$now = microtime(true);
$age = ceil(strtotime($configuration-&gt;getSMaxAge(), $now) - $now);
}
$response-&gt;setSharedMaxAge($age);
}
if (null !== $age = $configuration-&gt;getMaxAge()) {
if (!is_numeric($age)) {
$now = microtime(true);
$age = ceil(strtotime($configuration-&gt;getMaxAge(), $now) - $now);
}
$response-&gt;setMaxAge($age);
}
if (null !== $configuration-&gt;getExpires()) {
$date = \DateTime::createFromFormat(&#039;U&#039;, strtotime($configuration-&gt;getExpires()), new \DateTimeZone(&#039;UTC&#039;));
$response-&gt;setExpires($date);
}
if (null !== $configuration-&gt;getVary()) {
$response-&gt;setVary($configuration-&gt;getVary());
}
if ($configuration-&gt;isPublic()) {
$response-&gt;setPublic();
}
if ($configuration-&gt;isPrivate()) {
$response-&gt;setPrivate();
}
if (isset($this-&gt;lastModifiedDates[$request])) {
$response-&gt;setLastModified($this-&gt;lastModifiedDates[$request]);
unset($this-&gt;lastModifiedDates[$request]);
}
if (isset($this-&gt;etags[$request])) {
$response-&gt;setETag($this-&gt;etags[$request]);
unset($this-&gt;etags[$request]);
}
$event-&gt;setResponse($response);
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::CONTROLLER =&gt;&#039;onKernelController&#039;,
KernelEvents::RESPONSE =&gt;&#039;onKernelResponse&#039;,
);
}
private function getExpressionLanguage()
{
if (null === $this-&gt;expressionLanguage) {
if (!class_exists(&#039;Symfony\Component\ExpressionLanguage\ExpressionLanguage&#039;)) {
throw new \RuntimeException(&#039;Unable to use expressions as the Symfony ExpressionLanguage component is not installed.&#039;);
}
$this-&gt;expressionLanguage = new ExpressionLanguage();
}
return $this-&gt;expressionLanguage;
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Sensio\Bundle\FrameworkExtraBundle\Security\ExpressionLanguage;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\Security\Core\Authentication\AuthenticationTrustResolverInterface;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
use Symfony\Component\Security\Core\Authorization\AuthorizationCheckerInterface;
use Symfony\Component\Security\Core\SecurityContextInterface;
use Symfony\Component\Security\Core\Exception\AccessDeniedException;
use Symfony\Component\Security\Core\Role\RoleHierarchyInterface;
class SecurityListener implements EventSubscriberInterface
{
private $tokenStorage;
private $authChecker;
private $language;
private $trustResolver;
private $roleHierarchy;
public function __construct(SecurityContextInterface $securityContext = null, ExpressionLanguage $language = null, AuthenticationTrustResolverInterface $trustResolver = null, RoleHierarchyInterface $roleHierarchy = null, TokenStorageInterface $tokenStorage = null, AuthorizationCheckerInterface $authChecker = null)
{
$this-&gt;tokenStorage = $tokenStorage ?: $securityContext;
$this-&gt;authChecker = $authChecker ?: $securityContext;
$this-&gt;language = $language;
$this-&gt;trustResolver = $trustResolver;
$this-&gt;roleHierarchy = $roleHierarchy;
}
public function onKernelController(FilterControllerEvent $event)
{
$request = $event-&gt;getRequest();
if (!$configuration = $request-&gt;attributes-&gt;get(&#039;_security&#039;)) {
return;
}
if (null === $this-&gt;tokenStorage || null === $this-&gt;trustResolver) {
throw new \LogicException(&#039;To use the @Security tag, you need to install the Symfony Security bundle.&#039;);
}
if (null === $this-&gt;tokenStorage-&gt;getToken()) {
throw new \LogicException(&#039;To use the @Security tag, your controller needs to be behind a firewall.&#039;);
}
if (null === $this-&gt;language) {
throw new \LogicException(&#039;To use the @Security tag, you need to use the Security component 2.4 or newer and to install the ExpressionLanguage component.&#039;);
}
if (!$this-&gt;language-&gt;evaluate($configuration-&gt;getExpression(), $this-&gt;getVariables($request))) {
throw new AccessDeniedException(sprintf(&#039;Expression &quot;%s&quot; denied access.&#039;, $configuration-&gt;getExpression()));
}
}
private function getVariables(Request $request)
{
$token = $this-&gt;tokenStorage-&gt;getToken();
if (null !== $this-&gt;roleHierarchy) {
$roles = $this-&gt;roleHierarchy-&gt;getReachableRoles($token-&gt;getRoles());
} else {
$roles = $token-&gt;getRoles();
}
$variables = array(&#039;token&#039;=&gt; $token,&#039;user&#039;=&gt; $token-&gt;getUser(),&#039;object&#039;=&gt; $request,&#039;request&#039;=&gt; $request,&#039;roles&#039;=&gt; array_map(function ($role) { return $role-&gt;getRole(); }, $roles),&#039;trust_resolver&#039;=&gt; $this-&gt;trustResolver,&#039;auth_checker&#039;=&gt; $this-&gt;authChecker,
);
return array_merge($request-&gt;attributes-&gt;all(), $variables);
}
public static function getSubscribedEvents()
{
return array(KernelEvents::CONTROLLER =&gt;&#039;onKernelController&#039;);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Configuration
{
interface ConfigurationInterface
{
public function getAliasName();
public function allowArray();
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Configuration
{
abstract class ConfigurationAnnotation implements ConfigurationInterface
{
public function __construct(array $values)
{
foreach ($values as $k =&gt; $v) {
if (!method_exists($this, $name =&#039;set&#039;.$k)) {
throw new \RuntimeException(sprintf(&#039;Unknown key &quot;%s&quot; for annotation &quot;@%s&quot;.&#039;, $k, get_class($this)));
}
$this-&gt;$name($v);
}
}
}
}') in <a title="/home/hab/public_html/test/vendor/symfony/symfony/src/Symfony/Component/ClassLoader/ClassCollectionLoader.php line 122" ondblclick="var f=this.innerHTML;this.innerHTML=this.title;this.title=f;">ClassCollectionLoader.php line 122</a></li>
       <li>at <abbr title="Symfony\Component\ClassLoader\ClassCollectionLoader">ClassCollectionLoader</abbr>::load(<em>array</em>('Symfony\Bundle\FrameworkBundle\EventListener\SessionListener', 'Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage', 'Symfony\Component\HttpFoundation\Session\Storage\PhpBridgeSessionStorage', 'Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler', 'Symfony\Component\HttpFoundation\Session\Storage\Proxy\AbstractProxy', 'Symfony\Component\HttpFoundation\Session\Storage\Proxy\SessionHandlerProxy', 'Symfony\Component\HttpFoundation\Session\Session', 'Symfony\Bundle\FrameworkBundle\Templating\GlobalVariables', 'Symfony\Bundle\FrameworkBundle\Templating\TemplateReference', 'Symfony\Bundle\FrameworkBundle\Templating\TemplateNameParser', 'Symfony\Bundle\FrameworkBundle\Templating\Loader\TemplateLocator', 'Symfony\Component\Routing\Generator\UrlGenerator', 'Symfony\Component\Routing\RequestContext', 'Symfony\Component\Routing\Router', 'Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher', 'Symfony\Bundle\FrameworkBundle\Routing\Router', 'Symfony\Component\Config\FileLocator', 'Symfony\Component\Debug\ErrorHandler', 'Symfony\Component\EventDispatcher\Event', 'Symfony\Component\EventDispatcher\ContainerAwareEventDispatcher', 'Symfony\Component\HttpKernel\EventListener\ResponseListener', 'Symfony\Component\HttpKernel\EventListener\RouterListener', 'Symfony\Component\HttpKernel\Controller\ControllerResolver', 'Symfony\Component\HttpKernel\Event\KernelEvent', 'Symfony\Component\HttpKernel\Event\FilterControllerEvent', 'Symfony\Component\HttpKernel\Event\FilterResponseEvent', 'Symfony\Component\HttpKernel\Event\GetResponseEvent', 'Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent', 'Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent', 'Symfony\Component\HttpKernel\KernelEvents', 'Symfony\Component\HttpKernel\Config\FileLocator', 'Symfony\Bundle\FrameworkBundle\Controller\ControllerNameParser', 'Symfony\Bundle\FrameworkBundle\Controller\ControllerResolver', 'Symfony\Component\Security\Http\AccessMap', 'Symfony\Component\Security\Http\Firewall', 'Symfony\Component\Security\Core\User\UserProviderInterface', 'Symfony\Component\Security\Core\Authentication\AuthenticationProviderManager', 'Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorage', 'Symfony\Component\Security\Core\Authorization\AccessDecisionManager', 'Symfony\Component\Security\Core\Authorization\AuthorizationChecker', 'Symfony\Component\Security\Core\Authorization\Voter\VoterInterface', 'Symfony\Bundle\SecurityBundle\Security\FirewallMap', 'Symfony\Bundle\SecurityBundle\Security\FirewallContext', 'Symfony\Component\HttpFoundation\RequestMatcher', 'Twig_Environment', 'Twig_Extension', 'Twig_Extension_Core', 'Twig_Extension_Escaper', 'Twig_Extension_Optimizer', 'Twig_LoaderInterface', 'Twig_Markup', 'Twig_Template', 'Monolog\Formatter\FormatterInterface', 'Monolog\Formatter\LineFormatter', 'Monolog\Handler\HandlerInterface', 'Monolog\Handler\AbstractHandler', 'Monolog\Handler\AbstractProcessingHandler', 'Monolog\Handler\StreamHandler', 'Monolog\Handler\FingersCrossedHandler', 'Monolog\Handler\FilterHandler', 'Monolog\Handler\TestHandler', 'Monolog\Logger', 'Symfony\Bridge\Monolog\Logger', 'Symfony\Bridge\Monolog\Handler\DebugHandler', 'Monolog\Handler\FingersCrossed\ActivationStrategyInterface', 'Monolog\Handler\FingersCrossed\ErrorLevelActivationStrategy', 'Doctrine\Common\Annotations\DocLexer', 'Doctrine\Common\Annotations\FileCacheReader', 'Doctrine\Common\Annotations\PhpParser', 'Doctrine\Common\Annotations\Reader', 'Doctrine\Common\Lexer', 'Doctrine\Common\Persistence\ConnectionRegistry', 'Doctrine\Common\Persistence\Proxy', 'Doctrine\Common\Util\ClassUtils', 'Doctrine\Bundle\DoctrineBundle\Registry', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\ControllerListener', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\ParamConverterListener', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\DateTimeParamConverter', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\DoctrineParamConverter', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterInterface', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterManager', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\TemplateListener', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\HttpCacheListener', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\SecurityListener', 'Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationAnnotation'), '/home/hab/public_html/test/app/cache/dev', 'classes', <em>true</em>, <em>false</em>, '.php') in <a title="/home/hab/public_html/test/vendor/symfony/symfony/src/Symfony/Component/HttpKernel/Kernel.php line 408" ondblclick="var f=this.innerHTML;this.innerHTML=this.title;this.title=f;">Kernel.php line 408</a></li>
       <li>at <abbr title="Symfony\Component\HttpKernel\Kernel">Kernel</abbr>->doLoadClassCache('classes', '.php') in <a title="/home/hab/public_html/test/vendor/symfony/symfony/src/Symfony/Component/HttpKernel/Kernel.php line 126" ondblclick="var f=this.innerHTML;this.innerHTML=this.title;this.title=f;">Kernel.php line 126</a></li>
       <li>at <abbr title="Symfony\Component\HttpKernel\Kernel">Kernel</abbr>->boot() in <a title="/home/hab/public_html/test/vendor/symfony/symfony/src/Symfony/Component/HttpKernel/Kernel.php line 182" ondblclick="var f=this.innerHTML;this.innerHTML=this.title;this.title=f;">Kernel.php line 182</a></li>
       <li>at <abbr title="Symfony\Component\HttpKernel\Kernel">Kernel</abbr>->handle(<em>object</em>(<abbr title="Symfony\Component\HttpFoundation\Request">Request</abbr>)) in <a title="/home/hab/public_html/test/web/app_dev.php line 30" ondblclick="var f=this.innerHTML;this.innerHTML=this.title;this.title=f;">app_dev.php line 30</a></li>
    </ol>
</div>

            </div>
    </body>
</html>